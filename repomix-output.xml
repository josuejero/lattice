This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  ISSUE_TEMPLATE/
    bug_report.yml
    config.yml
    feature_request.yml
  workflows/
    ci.yml
  pull_request_template.md
apps/
  web/
    public/
      file.svg
      globe.svg
      next.svg
      vercel.svg
      window.svg
    src/
      app/
        (app)/
          audit/
            page.tsx
          availability/
            page.tsx
          dashboard/
            page.tsx
          events/
            [eventId]/
              page.tsx
            page.tsx
          integrations/
            google-calendar-panel.tsx
            page.tsx
          suggestions/
            page.tsx
          layout.tsx
        (auth)/
          signin/
            page.tsx
        (public)/
          page.tsx
        api/
          auth/
            [...nextauth]/
              route.ts
          db-ping/
            route.ts
          health/
            route.ts
          integrations/
            google/
              callback/
                route.ts
          openapi/
            route.ts
          orgs/
            [orgId]/
              availability/
                [userId]/
                  route.ts
                me/
                  overrides/
                    [overrideId]/
                      route.ts
                    route.ts
                  template/
                    route.ts
              events/
                [eventId]/
                  writeback/
                    google/
                      route.ts
                  route.ts
                route.ts
              integrations/
                google/
                  calendars/
                    route.ts
                  selections/
                    route.ts
                  start/
                    route.ts
                  sync/
                    route.ts
              members/
                [membershipId]/
                  route.ts
                route.ts
              suggestions/
                requests/
                  [requestId]/
                    confirm/
                      route.ts
                    route.ts
                  route.ts
              route.ts
            route.ts
        api-docs/
          page.tsx
        favicon.ico
        globals.css
        layout.tsx
      components/
        ui/
          button.tsx
          checkbox.tsx
          dialog.tsx
          dropdown-menu.tsx
          form.tsx
          input.tsx
          label.tsx
          select.tsx
          sonner.tsx
          table.tsx
        providers.tsx
      features/
        availability/
          AvailabilityClient.tsx
        events/
          WriteBackButton.tsx
        suggestions/
          SuggestionsClient.tsx
      lib/
        availability/
          intervals.test.ts
          intervals.ts
          time.ts
        crypto/
          secretbox.ts
        events/
          conflicts.test.ts
          conflicts.ts
        google/
          calendar.ts
          oauth.ts
        suggestions/
          demo-busy.ts
          engine.test.ts
          engine.ts
          state.ts
        env.ts
        guards.ts
        http.ts
        idempotency.ts
        openapi.ts
        org-context.ts
        rbac.ts
        slugify.ts
        utils.ts
      types/
        next-auth.d.ts
      auth.ts
      middleware.ts
    test-results/
      .last-run.json
    tests/
      e2e/
        helpers/
          demo-flow.ts
        auth-smoke.spec.ts
        availability.spec.ts
        confirm.spec.ts
        home.spec.ts
        suggestions.spec.ts
      unit/
        openapi.test.ts
        rbac.test.ts
        smoke.test.ts
    .gitignore
    components.json
    eslint.config.mjs
    next.config.ts
    package.json
    playwright.config.ts
    postcss.config.mjs
    README.md
    tsconfig.json
    vitest.config.ts
docs/
  adr/
    0001-template.md
  api.md
  architecture.md
  fairness-engine.md
  threat-model.md
packages/
  db/
    prisma/
      migrations/
        20260105215837_init/
          migration.sql
        20260106000452_availability_profiles/
          migration.sql
        20260106020655_phase4_google_calendar/
          migration.sql
        20260106031037_phase5_scheduled_events/
          migration.sql
        20260106120000_phase5_idempotency/
          migration.sql
        20260106123000_phase6a_audit_logs/
          migration.sql
        migration_lock.toml
      schema.prisma
      seed.ts
    src/
      index.ts
    eslint.config.cjs
    package.json
    tsconfig.json
  shared/
    src/
      audit/
        log.ts
      http/
        envelope.ts
        error-codes.ts
        rate-limit.ts
      redis/
        client.ts
      env.ts
      index.ts
    eslint.config.cjs
    package.json
    tsconfig.json
scripts/
  run-local-e2e.sh
types/
  lattice-db.d.ts
.env.example
.gitignore
.nvmrc
.prettierignore
.prettierrc.json
.tool-versions
CODE_OF_CONDUCT.md
CONTRIBUTING.md
docker-compose.yml
LICENSE
package.json
pnpm-workspace.yaml
README.md
SECURITY.md
tsconfig.base.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/ISSUE_TEMPLATE/bug_report.yml">
name: Bug report
about: Report a reproducible bug so we can quickly fix it.
title: "[BUG] "
labels: bug
body:
  - type: markdown
    attributes:
      value: |
        Thanks for reporting! Provide as much detail as you can so we can reproduce the issue reliably.
  - type: input
    id: summary
    attributes:
      label: Summary
      description: Describe the incorrect behavior or failure.
      placeholder: "What happens?"
      required: true
  - type: textarea
    id: steps
    attributes:
      label: Steps to reproduce
      description: List the steps that consistently reproduce the issue.
      placeholder: |
        1. Clone the repo
        2. ...
      required: true
  - type: textarea
    id: expected
    attributes:
      label: Expected behavior
      description: What you expected to happen.
  - type: textarea
    id: actual
    attributes:
      label: Actual behavior
      description: What actually happened (error message, crash, etc.).
  - type: textarea
    id: environment
    attributes:
      label: Environment
      description: Include OS, node/pnpm versions, relevant package versions.
      placeholder: |
        macOS 13.4
        Node 20.5.1
        pnpm 8.15.0
  - type: textarea
    id: logs
    attributes:
      label: Additional context
      description: Logs, screenshots, or other supporting information.
</file>

<file path=".github/ISSUE_TEMPLATE/config.yml">
blank_issues_enabled: false
contact_links:
  - name: Discussions
    url: https://github.com/josuejero/lattice/discussions
    about: Ask community questions or share broader ideas.
  - name: Docs
    url: https://github.com/josuejero/lattice#readme
    about: See setup guides and architecture notes.
</file>

<file path=".github/ISSUE_TEMPLATE/feature_request.yml">
name: Feature request
about: Share ideas or improvements that help the project grow.
title: "[FEATURE] "
labels: enhancement
body:
  - type: markdown
    attributes:
      value: |
        Thanks for improving Lattice! Help us understand the motivation and value of this request.
  - type: input
    id: summary
    attributes:
      label: Summary
      description: What capability are you proposing?
      placeholder: "Allow syncing calendars from other providers..."
      required: true
  - type: textarea
    id: motivation
    attributes:
      label: Motivation
      description: Why is this change important? Who benefits?
  - type: textarea
    id: user_story
    attributes:
      label: Proposed solution or user story
      description: Optional: describe how you envision the feature working.
  - type: textarea
    id: alternatives
    attributes:
      label: Alternatives considered
      description: What else did you try or consider?
  - type: textarea
    id: impact
    attributes:
      label: Impact
      description: How would this change affect developers or end users?
</file>

<file path=".github/pull_request_template.md">
## Summary
- What change you made and why.
- Keep bullet list short and focused on functionality and impact.

## Testing
- `pnpm -w lint typecheck test build` *(if relevant, describe which commands you ran and their results)*
- Additional manual or e2e tests (describe steps)

## Related
- Resolves # (if applicable)
- Depends on # (if applicable)

## Checklist
- [ ] I followed the contributing guidelines and documented any special setup.
- [ ] I included tests or updated existing ones when behavior changed.
- [ ] Pre-release commands (e.g., `pnpm -w dev`) were run locally to validate the flow.
</file>

<file path="apps/web/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="apps/web/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="apps/web/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="apps/web/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="apps/web/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="apps/web/src/app/(app)/audit/page.tsx">
import { prisma } from "@lattice/db";
import { auth } from "@/auth";
import { redirect } from "next/navigation";
import { getActiveOrgId } from "@/lib/org-context";
import { requireOrgAccess } from "@/lib/guards";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

export default async function AuditPage() {
  const session = await auth();
  if (!session?.user?.id) redirect("/signin");

  const orgId = await getActiveOrgId();
  if (!orgId) redirect("/dashboard");

  const access = await requireOrgAccess(orgId, { minRole: "ADMIN" });
  if (!access.ok) redirect("/dashboard");

  const logs = await prisma.auditLog.findMany({
    where: { orgId },
    orderBy: { createdAt: "desc" },
    take: 20,
    include: { actorUser: { select: { id: true, email: true, name: true } } },
  });

  return (
    <main className="mx-auto max-w-5xl p-6 space-y-6">
      <div className="space-y-2">
        <h1 className="text-2xl font-semibold">Audit log</h1>
        <p className="text-sm text-muted-foreground">
          Latest sensitive events for this organization. Only admins can view this data.
        </p>
        <a className="text-sm underline" href="/dashboard">
          Back to dashboard
        </a>
      </div>

      <section className="rounded-xl border bg-background p-4">
        {logs.length === 0 ? (
          <p className="text-sm text-muted-foreground">No audit events recorded yet.</p>
        ) : (
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Timestamp</TableHead>
                <TableHead>Action</TableHead>
                <TableHead>Actor</TableHead>
                <TableHead>Target</TableHead>
                <TableHead>Metadata</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {logs.map((log) => {
                const actor =
                  log.actorUser?.name ??
                  log.actorUser?.email ??
                  "system";
                const target =
                  log.targetType && log.targetId
                    ? `${log.targetType} ${log.targetId}`
                    : log.targetType ?? "(none)";
                const metadataString = log.metadata
                  ? JSON.stringify(log.metadata)
                  : "";
                const metaPreview =
                  metadataString.length > 180
                    ? `${metadataString.slice(0, 180)}…`
                    : metadataString || "-";

                return (
                  <TableRow key={log.id}>
                    <TableCell>{log.createdAt.toISOString()}</TableCell>
                    <TableCell className="font-medium">{log.action}</TableCell>
                    <TableCell>{actor}</TableCell>
                    <TableCell>{target}</TableCell>
                    <TableCell className="break-words">{metaPreview}</TableCell>
                  </TableRow>
                )
              })}
            </TableBody>
          </Table>
        )}
      </section>
    </main>
  );
}
</file>

<file path="apps/web/src/app/(app)/availability/page.tsx">
import { redirect } from "next/navigation"
import { auth } from "@/auth"
import { getActiveOrgId } from "@/lib/org-context"
import AvailabilityClient from "@/features/availability/AvailabilityClient"

export default async function AvailabilityPage() {
  const session = await auth()
  if (!session?.user?.id) redirect("/signin")

  const orgId = await getActiveOrgId()
  if (!orgId) redirect("/dashboard")

  return (
    <div style={{ padding: 24 }}>
      <h1>Availability</h1>
      <p>Set your weekly availability and add overrides for specific dates.</p>
      <AvailabilityClient orgId={orgId} />
    </div>
  )
}
</file>

<file path="apps/web/src/app/(app)/events/[eventId]/page.tsx">
import Link from "next/link";

import { prisma } from "@lattice/db";
import { env } from "@/lib/env";
import { getActiveOrgId } from "@/lib/org-context";
import { requireMembership } from "@/lib/guards";
import { WriteBackButton } from "@/features/events/WriteBackButton";

export default async function EventDetailPage(props: { params: Promise<{ eventId: string }> }) {
  if (!env.EVENTS_ENABLED) return <div>Events are disabled.</div>;

  const { eventId } = await props.params;
  const orgId = await getActiveOrgId();
  if (!orgId) return <div>Sign in required.</div>;

  const access = await requireMembership(orgId);
  if (!access.ok) return <div>Sign in required.</div>;

  const event = await prisma.scheduledEvent.findFirst({
    where: { id: eventId, orgId },
    include: { attendees: { include: { user: { select: { id: true, name: true, email: true } } } } },
  });
  if (!event) return <div>Not found.</div>;

  return (
    <div style={{ padding: 16 }}>
      <p>
        <Link href="/events">← Back</Link>
      </p>

      <h1>{event.title}</h1>
      <p>
        <strong>Time:</strong> {event.startUtc.toISOString()} → {event.endUtc.toISOString()} ({event.timeZone})
      </p>

      {event.notes ? (
        <p>
          <strong>Notes:</strong> {event.notes}
        </p>
      ) : null}

      <p>
        <strong>Write-back:</strong> {event.writeBackStatus}
        {event.externalEventHtmlLink ? (
          <>
            {" "}
            ·{" "}
            <a href={event.externalEventHtmlLink} target="_blank" rel="noreferrer">
              Open in Google Calendar
            </a>
          </>
        ) : null}
      </p>

      {env.GCAL_WRITEBACK_ENABLED ? (
        <div style={{ marginTop: 12 }}>
          <WriteBackButton orgId={orgId} eventId={event.id} />
        </div>
      ) : null}

      <h2 style={{ marginTop: 16 }}>Attendees</h2>
      <ul>
        {event.attendees.map((a) => (
          <li key={a.id}>
            {a.user.name ?? a.user.email ?? a.user.id} - <small>{a.rsvp}</small>
          </li>
        ))}
      </ul>
    </div>
  );
}
</file>

<file path="apps/web/src/app/(app)/events/page.tsx">
import Link from "next/link";

import { prisma } from "@lattice/db";
import { env } from "@/lib/env";
import { getActiveOrgId } from "@/lib/org-context";
import { requireMembership } from "@/lib/guards";

export default async function EventsPage() {
  if (!env.EVENTS_ENABLED) return <div>Events are disabled.</div>;

  const orgId = await getActiveOrgId();
  if (!orgId) return <div>Sign in required.</div>;

  const access = await requireMembership(orgId);
  if (!access.ok) return <div>Sign in required.</div>;

  const now = new Date();
  const events = await prisma.scheduledEvent.findMany({
    where: { orgId, endUtc: { gte: now } },
    orderBy: { startUtc: "asc" },
    take: 50,
  });

  return (
    <div style={{ padding: 16 }}>
      <h1>Events</h1>
      <div style={{ marginTop: 12 }}>
        {events.length === 0 ? (
          <p>No upcoming events yet.</p>
        ) : (
          <ul>
            {events.map((e) => (
              <li key={e.id}>
                <Link href={`/events/${e.id}`}>{e.title}</Link>{" "}
                <small>
                  ({e.startUtc.toISOString()} → {e.endUtc.toISOString()})
                </small>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}
</file>

<file path="apps/web/src/app/(app)/integrations/page.tsx">
import { redirect } from "next/navigation";
import { auth } from "@/auth";
import { prisma } from "@lattice/db";
import { getActiveOrgId } from "@/lib/org-context";
import { requireMembership } from "@/lib/guards";
import { GoogleCalendarPanel } from "./google-calendar-panel";

export default async function IntegrationsPage() {
  const session = await auth();
  if (!session?.user?.id) redirect("/signin");
  const userId = session.user.id;

  const orgId = await getActiveOrgId();
  if (!orgId) redirect("/dashboard");

  const access = await requireMembership(orgId);
  if (!access.ok) redirect("/dashboard");

  const conn = await prisma.calendarConnection.findUnique({
    where: { userId_provider: { userId, provider: "GOOGLE" } },
    select: { status: true, lastSyncAt: true },
  });

  const connected = !!conn && conn.status === "ACTIVE";

  return (
    <main className="mx-auto max-w-3xl p-6 space-y-6">
      <h1 className="text-2xl font-semibold">Integrations</h1>

      <section className="rounded-xl border p-4 space-y-3">
        <h2 className="text-xl font-medium">Google Calendar</h2>

        {!connected ? (
          <>
            <p className="text-sm text-muted-foreground">
              Import busy time ranges only (no event titles). Busy blocks will be treated as hard “unavailable.”
            </p>
            <a className="underline" href={`/api/orgs/${orgId}/integrations/google/start`}>
              Connect Google Calendar
            </a>
          </>
        ) : (
          <>
            <p className="text-sm text-muted-foreground">
              Connected {conn?.lastSyncAt ? `(last sync: ${conn.lastSyncAt.toISOString()})` : "(not synced yet)"}
            </p>
            <GoogleCalendarPanel orgId={orgId} />
          </>
        )}
      </section>
    </main>
  );
}
</file>

<file path="apps/web/src/app/(auth)/signin/page.tsx">
import { signIn } from "@/auth";

export default function SignInPage() {
  return (
    <main style={{ padding: 24, maxWidth: 480 }}>
      <h1>Sign in</h1>

      <form
        action={async (formData) => {
          "use server";
          const email = String(formData.get("email") ?? "");
          await signIn("credentials", { email, redirectTo: "/dashboard" });
        }}
        style={{ display: "grid", gap: 12, marginTop: 16 }}
      >
        <label>
          Email (dev/test)
          <input
            name="email"
            type="email"
            required
            style={{ width: "100%", padding: 8, marginTop: 6 }}
            placeholder="dev@example.com"
          />
        </label>
        <button type="submit" style={{ padding: 10 }}>
          Continue
        </button>
      </form>

      <hr style={{ margin: "24px 0" }} />

      <form
        action={async () => {
          "use server";
          await signIn("google", { redirectTo: "/dashboard" });
        }}
      >
        <button type="submit" style={{ padding: 10, width: "100%" }}>
          Continue with Google
        </button>
      </form>

      <p style={{ marginTop: 16, opacity: 0.8 }}>
        If Google env vars are not set, the Google button will fail. Dev sign-in
        works in non-production environments.
      </p>
    </main>
  );
}
</file>

<file path="apps/web/src/app/(public)/page.tsx">
export default function Home() {
  return (
    <main style={{ padding: 24 }}>
      <h1>Lattice</h1>
      <p>Privacy-respecting group scheduling — foundations.</p>
      <p>
        Health check: <code>/api/health</code>
      </p>
    </main>
  );
}
</file>

<file path="apps/web/src/app/api/openapi/route.ts">
import { NextResponse } from "next/server";

import { getOpenApiSpec } from "@/lib/openapi";

export async function GET() {
  return NextResponse.json(getOpenApiSpec());
}
</file>

<file path="apps/web/src/app/api-docs/page.tsx">
"use client";

import SwaggerUI from "swagger-ui-react";

export default function ApiDocsPage() {
  return (
    <main className="min-h-screen bg-background text-foreground">
      <div className="mx-auto w-full max-w-6xl px-4 py-8">
        <h1 className="mb-4 text-3xl font-semibold">Lattice API docs</h1>
        <SwaggerUI url="/api/openapi" docExpansion="list" />
      </div>
    </main>
  );
}
</file>

<file path="apps/web/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="apps/web/src/components/ui/checkbox.tsx">
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="grid place-content-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }
</file>

<file path="apps/web/src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 outline-none sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="apps/web/src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Slot } from "@radix-ui/react-slot"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  asChild = false,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : DropdownMenuPrimitive.Trigger

  return (
    <Comp data-slot="dropdown-menu-trigger" {...props} />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  asChild = false,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : DropdownMenuPrimitive.Item

  return (
    <Comp
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </Comp>
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="apps/web/src/components/ui/form.tsx">
"use client"

import * as React from "react"
import type * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="apps/web/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="apps/web/src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="apps/web/src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "item-aligned",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span
        data-slot="select-item-indicator"
        className="absolute right-2 flex size-3.5 items-center justify-center"
      >
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="apps/web/src/components/ui/sonner.tsx">
"use client"

import {
  CircleCheckIcon,
  InfoIcon,
  Loader2Icon,
  OctagonXIcon,
  TriangleAlertIcon,
} from "lucide-react"
import { useTheme } from "next-themes"
import { Toaster as Sonner, type ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      icons={{
        success: <CircleCheckIcon className="size-4" />,
        info: <InfoIcon className="size-4" />,
        warning: <TriangleAlertIcon className="size-4" />,
        error: <OctagonXIcon className="size-4" />,
        loading: <Loader2Icon className="size-4 animate-spin" />,
      }}
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
          "--border-radius": "var(--radius)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="apps/web/src/components/ui/table.tsx">
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="apps/web/src/components/providers.tsx">
"use client"

import * as React from "react"
import { ThemeProvider } from "next-themes"

import { Toaster } from "@/components/ui/sonner"

type ProvidersProps = {
  children: React.ReactNode
}

export function AppProviders({ children }: ProvidersProps) {
  return (
    <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
      {children}
      <Toaster />
    </ThemeProvider>
  )
}
</file>

<file path="apps/web/src/lib/availability/intervals.test.ts">
import { describe, expect, it } from "vitest"
import { normalizeIntervals, subtractIntervals, unionIntervals } from "./intervals"

describe("availability intervals", () => {
  it("merges overlaps", () => {
    expect(normalizeIntervals([{ start: 60, end: 120 }, { start: 110, end: 180 }])).toEqual([
      { start: 60, end: 180 },
    ])
  })

  it("subtracts correctly", () => {
    expect(subtractIntervals([{ start: 60, end: 180 }], [{ start: 90, end: 120 }])).toEqual([
      { start: 60, end: 90 },
      { start: 120, end: 180 },
    ])
  })

  it("unions correctly", () => {
    expect(unionIntervals([{ start: 60, end: 90 }], [{ start: 80, end: 120 }])).toEqual([
      { start: 60, end: 120 },
    ])
  })
})
</file>

<file path="apps/web/src/lib/availability/intervals.ts">
export type Interval = { start: number; end: number } // minutes from midnight

export function clampMinute(n: number): number {
  if (Number.isNaN(n)) return 0
  return Math.max(0, Math.min(1440, Math.trunc(n)))
}

export function normalizeIntervals(
  intervals: Interval[],
  { minSize = 15 }: { minSize?: number } = {},
): Interval[] {
  const cleaned = intervals
    .map((i) => ({ start: clampMinute(i.start), end: clampMinute(i.end) }))
    .filter((i) => i.start < i.end)
    .filter((i) => i.end - i.start >= minSize)
    .sort((a, b) => a.start - b.start)

  const merged: Interval[] = []
  for (const cur of cleaned) {
    const last = merged[merged.length - 1]
    if (!last || cur.start > last.end) merged.push({ ...cur })
    else last.end = Math.max(last.end, cur.end)
  }
  return merged
}

export function unionIntervals(
  base: Interval[],
  add: Interval[],
  options?: { minSize?: number },
): Interval[] {
  return normalizeIntervals([...base, ...add], options)
}

// Subtract remove[] from base[]
export function subtractIntervals(
  base: Interval[],
  remove: Interval[],
  options?: { minSize?: number },
): Interval[] {
  const b = normalizeIntervals(base, options)
  const r = normalizeIntervals(remove, options)
  if (r.length === 0) return b

  const out: Interval[] = []

  for (const bi of b) {
    let fragments: Interval[] = [bi]

    for (const ri of r) {
      const next: Interval[] = []
      for (const f of fragments) {
        // no overlap
        if (ri.end <= f.start || ri.start >= f.end) {
          next.push(f)
          continue
        }
        // overlap: split
        if (ri.start > f.start) next.push({ start: f.start, end: ri.start })
        if (ri.end < f.end) next.push({ start: ri.end, end: f.end })
      }
      fragments = next
      if (fragments.length === 0) break
    }

    out.push(...fragments)
  }

  return normalizeIntervals(out, options)
}
</file>

<file path="apps/web/src/lib/availability/time.ts">
import { DateTime } from "luxon"
import type { Interval } from "./intervals"

export function minutesFromTimeString(t: string): number {
  const [hh, mm] = t.split(":").map((x) => Number(x))
  const h = Number.isFinite(hh) ? hh : 0
  const m = Number.isFinite(mm) ? mm : 0
  return h * 60 + m
}

export function parseHHMM(hhmm: string) {
  const [hourRaw, minuteRaw] = hhmm.split(":")
  if (!hourRaw || !minuteRaw) {
    throw new Error(`Invalid time: ${hhmm}`)
  }

  const hour = Number(hourRaw)
  const minute = Number(minuteRaw)

  if (
    !Number.isFinite(hour) ||
    !Number.isFinite(minute) ||
    hour < 0 ||
    hour > 23 ||
    minute < 0 ||
    minute > 59
  ) {
    throw new Error(`Invalid time: ${hhmm}`)
  }

  return hour * 60 + minute
}

export function timeStringFromMinutes(mins: number): string {
  const m = Math.max(0, Math.min(1439, Math.trunc(mins)))
  const hh = String(Math.floor(m / 60)).padStart(2, "0")
  const mm = String(m % 60).padStart(2, "0")
  return `${hh}:${mm}`
}

export function toUtcIsoFromLocal(
  dateISO: string,
  timeHHMM: string,
  timeZone: string,
): string {
  const [hh, mm] = timeHHMM.split(":").map((x) => Number(x))
  const dt = DateTime.fromISO(dateISO, { zone: timeZone }).set({
    hour: hh || 0,
    minute: mm || 0,
    second: 0,
    millisecond: 0,
  })
  return dt.toUTC().toISO()!
}

export function overrideToLocalIntervalForDate(
  override: { startAt: string; endAt: string },
  dateISO: string,
  timeZone: string,
): Interval | null {
  const dayStart = DateTime.fromISO(dateISO, { zone: timeZone }).startOf("day")
  const dayEnd = dayStart.plus({ days: 1 })

  const start = DateTime.fromISO(override.startAt, { zone: "utc" }).setZone(timeZone)
  const end = DateTime.fromISO(override.endAt, { zone: "utc" }).setZone(timeZone)

  const s = start < dayStart ? dayStart : start
  const e = end > dayEnd ? dayEnd : end

  if (e <= s) return null

  return {
    start: Math.floor(s.diff(dayStart, "minutes").minutes),
    end: Math.ceil(e.diff(dayStart, "minutes").minutes),
  }
}
</file>

<file path="apps/web/src/lib/crypto/secretbox.ts">
import crypto from "crypto";
import { env } from "@/lib/env";

function key(): Buffer {
  const raw = env.TOKEN_ENC_KEY;
  if (!raw) throw new Error("TOKEN_ENC_KEY is required for calendar integration");
  const buf = Buffer.from(raw, "base64");
  if (buf.length !== 32) throw new Error("TOKEN_ENC_KEY must decode to 32 bytes");
  return buf;
}

export function encryptString(plaintext: string): string {
  const iv = crypto.randomBytes(12);
  const cipher = crypto.createCipheriv("aes-256-gcm", key(), iv);
  const ciphertext = Buffer.concat([cipher.update(plaintext, "utf8"), cipher.final()]);
  const tag = cipher.getAuthTag();
  return `v1.${iv.toString("base64url")}.${tag.toString("base64url")}.${ciphertext.toString("base64url")}`;
}

export function decryptString(payload: string): string {
  const [v, ivB64, tagB64, ctB64] = payload.split(".");
  if (v !== "v1" || !ivB64 || !tagB64 || !ctB64) throw new Error("Bad ciphertext");
  const iv = Buffer.from(ivB64, "base64url");
  const tag = Buffer.from(tagB64, "base64url");
  const ct = Buffer.from(ctB64, "base64url");
  const decipher = crypto.createDecipheriv("aes-256-gcm", key(), iv);
  decipher.setAuthTag(tag);
  return Buffer.concat([decipher.update(ct), decipher.final()]).toString("utf8");
}
</file>

<file path="apps/web/src/lib/events/conflicts.test.ts">
import { test, expect } from "vitest";

import { findConflictingUserIds, intervalsOverlap } from "./conflicts";

test("edge intervals do not overlap when end equals start", () => {
  const start = new Date("2025-04-01T10:00:00Z");
  const end = new Date("2025-04-01T11:00:00Z");
  const nextStart = new Date("2025-04-01T11:00:00Z");
  const nextEnd = new Date("2025-04-01T12:00:00Z");

  expect(intervalsOverlap(start, end, nextStart, nextEnd)).toBe(false);
  expect(intervalsOverlap(nextStart, nextEnd, start, end)).toBe(false);
});

test("contained intervals overlap", () => {
  const outerStart = new Date("2025-05-01T09:00:00Z");
  const outerEnd = new Date("2025-05-01T11:00:00Z");
  const innerStart = new Date("2025-05-01T09:30:00Z");
  const innerEnd = new Date("2025-05-01T10:30:00Z");

  expect(intervalsOverlap(outerStart, outerEnd, innerStart, innerEnd)).toBe(true);
});

test("finds conflicting users across multiple intervals", () => {
  const intervalStart = new Date("2025-06-01T10:00:00Z");
  const intervalEnd = new Date("2025-06-01T11:00:00Z");

  const entries = [
    { userId: "alice", start: new Date("2025-06-01T09:30:00Z"), end: new Date("2025-06-01T10:15:00Z") },
    { userId: "bob", start: new Date("2025-06-01T10:30:00Z"), end: new Date("2025-06-01T11:30:00Z") },
    { userId: "alice", start: new Date("2025-06-01T09:45:00Z"), end: new Date("2025-06-01T10:05:00Z") },
    { userId: "charlie", start: new Date("2025-06-01T11:00:00Z"), end: new Date("2025-06-01T12:00:00Z") },
  ];

  const conflicts = findConflictingUserIds({ intervalStart, intervalEnd, intervals: entries });
  expect(conflicts).toEqual(["alice", "bob"]);
});
</file>

<file path="apps/web/src/lib/events/conflicts.ts">
export type ConflictInterval = {
  userId: string;
  start: Date;
  end: Date;
};

export function intervalsOverlap(
  aStart: Date,
  aEnd: Date,
  bStart: Date,
  bEnd: Date,
) {
  return aStart < bEnd && aEnd > bStart;
}

export function findConflictingUserIds({
  intervalStart,
  intervalEnd,
  intervals,
}: {
  intervalStart: Date;
  intervalEnd: Date;
  intervals: ConflictInterval[];
}) {
  const seen = new Set<string>();
  for (const interval of intervals) {
    if (intervalsOverlap(intervalStart, intervalEnd, interval.start, interval.end)) {
      seen.add(interval.userId);
    }
  }
  return [...seen].sort();
}
</file>

<file path="apps/web/src/lib/google/oauth.ts">
import crypto from "crypto";
import { cookies } from "next/headers";
import { env } from "@/lib/env";

const COOKIE = "lattice_gcal_oauth";

const b64url = (buf: Buffer) => buf.toString("base64url");
const sign = (json: string) => crypto.createHmac("sha256", env.AUTH_SECRET).update(json).digest("base64url");

export function createPkcePair() {
  const verifier = b64url(crypto.randomBytes(32));
  const challenge = b64url(crypto.createHash("sha256").update(verifier).digest());
  return { verifier, challenge };
}

export async function setOauthCookie(payload: Record<string, unknown>) {
  const json = JSON.stringify(payload);
  const value = `${b64url(Buffer.from(json))}.${sign(json)}`;
  ;(await cookies()).set(COOKIE, value, {
    httpOnly: true,
    sameSite: "lax",
    secure: process.env.NODE_ENV === "production",
    path: "/",
    maxAge: 10 * 60,
  });
}

export async function readOauthCookie() {
  const raw = (await cookies()).get(COOKIE)?.value;
  if (!raw) return null;
  const [payloadB64, sig] = raw.split(".");
  if (!payloadB64 || !sig) return null;
  const json = Buffer.from(payloadB64, "base64url").toString("utf8");
  if (sign(json) !== sig) return null;
  return JSON.parse(json) as Record<string, unknown>;
}

export async function clearOauthCookie() {
  ;(await cookies()).set(COOKIE, "", { path: "/", maxAge: 0 });
}
</file>

<file path="apps/web/src/lib/suggestions/demo-busy.ts">
import { createHash } from "crypto";
import { DateTime } from "luxon";

const WEEK_SPREAD = 2;
const MAX_SHIFT_MINUTES = 40;
const EARLIEST_MINUTE = 6 * 60;
const LATEST_MINUTE = 21 * 60;

const BASE_PATTERNS: Array<{ dayOffset: number; baseStartMinute: number; durationMinutes: number }> = [
  { dayOffset: 0, baseStartMinute: 9 * 60, durationMinutes: 90 },
  { dayOffset: 1, baseStartMinute: 11 * 60 + 15, durationMinutes: 60 },
  { dayOffset: 2, baseStartMinute: 14 * 60, durationMinutes: 75 },
  { dayOffset: 3, baseStartMinute: 8 * 60 + 30, durationMinutes: 120 },
  { dayOffset: 4, baseStartMinute: 13 * 60 + 30, durationMinutes: 60 },
];

type DemoBusyBlock = {
  userId: string;
  startUtc: Date;
  endUtc: Date;
  createdAt: Date;
};

function clampStartMinute(base: number, duration: number): number {
  const maxStart = Math.max(EARLIEST_MINUTE, LATEST_MINUTE - duration);
  return Math.min(Math.max(base, EARLIEST_MINUTE), maxStart);
}

function shiftMinutes(userId: string, weekKey: string, pattern: { dayOffset: number }): number {
  const digest = createHash("sha256")
    .update(`${userId}:${weekKey}:${pattern.dayOffset}`)
    .digest("hex");
  const raw = parseInt(digest.slice(0, 4), 16);
  const range = MAX_SHIFT_MINUTES * 2 + 1;
  return (raw % range) - MAX_SHIFT_MINUTES;
}

function mondayOf(date: DateTime) {
  return date.minus({ days: date.weekday - 1 }).startOf("day");
}

export function generateDemoBusyBlocks(params: {
  userId: string;
  rangeStart: Date;
  rangeEnd: Date;
}): DemoBusyBlock[] {
  const rangeStart = DateTime.fromJSDate(params.rangeStart, { zone: "utc" });
  const rangeEnd = DateTime.fromJSDate(params.rangeEnd, { zone: "utc" });
  const baseWeek = mondayOf(DateTime.utc());
  const blocks: DemoBusyBlock[] = [];

  for (let weekOffset = 0; weekOffset < WEEK_SPREAD; weekOffset += 1) {
    const weekStart = baseWeek.plus({ weeks: weekOffset });
    for (const pattern of BASE_PATTERNS) {
      const weekKey = weekStart.toISODate();
      const shift = shiftMinutes(params.userId, weekKey, pattern);
      const adjustedStart = clampStartMinute(pattern.baseStartMinute + shift, pattern.durationMinutes);
      const dayStart = weekStart.plus({ days: pattern.dayOffset, minutes: adjustedStart });
      const dayEnd = dayStart.plus({ minutes: pattern.durationMinutes });

      if (dayEnd <= rangeStart || dayStart >= rangeEnd) continue;

      blocks.push({
        userId: params.userId,
        startUtc: dayStart.toJSDate(),
        endUtc: dayEnd.toJSDate(),
        createdAt: dayStart.toJSDate(),
      });
    }
  }

  return blocks;
}
</file>

<file path="apps/web/src/lib/suggestions/engine.ts">
import { DateTime } from "luxon"
import { createHash } from "crypto"

import type { Interval } from "@/lib/availability/intervals"
import { normalizeIntervals, subtractIntervals, unionIntervals } from "@/lib/availability/intervals"
import { overrideToLocalIntervalForDate } from "@/lib/availability/time"

export type OverrideDTO = {
  startAt: string
  endAt: string
  kind: "AVAILABLE" | "UNAVAILABLE"
}

export type WindowDTO = {
  dayOfWeek: number
  startMinute: number
  endMinute: number
}

export type AttendeeAvailabilityInput = {
  userId: string
  timeZone: string
  windows: WindowDTO[]
  overrides: OverrideDTO[]
}

export type SuggestionScores = {
  total: number
  attendance: number
  inconvenience: number
  fairness: number
}

export type SuggestionCandidate = {
  rank: number
  startAt: string
  endAt: string
  attendanceRatio: number
  score: SuggestionScores
  availableUserIds: string[]
  missingUserIds: string[]
  explanation: {
    why: string[]
    worstLocalTime?: {
      userId: string
      localStart: string
      localEnd: string
      timeZone: string
      penalty: number
    }
  }
}

export type GenerateSuggestionsInput = {
  timeZone: string
  rangeStart: string
  rangeEnd: string
  durationMinutes: number
  stepMinutes: number
  dayStartMinute: number
  dayEndMinute: number
  attendees: AttendeeAvailabilityInput[]
  maxCandidates?: number
}

export function computeRequestKey(
  input: Omit<GenerateSuggestionsInput, "attendees" | "maxCandidates"> & { attendeeUserIds: string[] },
) {
  const stable = {
    ...input,
    attendeeUserIds: [...input.attendeeUserIds].sort(),
  }
  return createHash("sha256").update(JSON.stringify(stable)).digest("hex")
}

function clamp01(value: number) {
  return Math.max(0, Math.min(1, value))
}

function penaltyForLocalInterval(startMinute: number, endMinute: number) {
  const startHour = startMinute / 60
  const endHour = endMinute / 60

  if (startHour >= 9 && endHour <= 17) return 0
  if (startHour >= 8 && endHour <= 18) return 0.25
  if (startHour >= 7 && endHour <= 19) return 0.6
  return 1
}

function minutesSinceStartOfDay(dt: DateTime) {
  return Math.round(dt.diff(dt.startOf("day"), "minutes").minutes)
}

function indexOverridesByLocalDate(timeZone: string, overrides: OverrideDTO[]) {
  const map = new Map<string, OverrideDTO[]>()

  for (const override of overrides) {
    const startLocal = DateTime.fromISO(override.startAt, { zone: "utc" }).setZone(timeZone)
    const endLocal = DateTime.fromISO(override.endAt, { zone: "utc" }).setZone(timeZone)

    let cursor = startLocal.startOf("day")
    const last = endLocal.startOf("day")

    while (cursor <= last) {
      const dateISO = cursor.toISODate()
      if (dateISO) {
        const list = map.get(dateISO) ?? []
        list.push(override)
        map.set(dateISO, list)
      }
      cursor = cursor.plus({ days: 1 })
    }
  }

  return map
}

function buildWindowsByDay(windows: WindowDTO[]) {
  const byDay = new Map<number, Interval[]>()

  for (const window of windows) {
    const list = byDay.get(window.dayOfWeek) ?? []
    list.push({ start: window.startMinute, end: window.endMinute })
    byDay.set(window.dayOfWeek, list)
  }

  for (const [day, list] of byDay.entries()) {
    byDay.set(day, normalizeIntervals(list, { minSize: 1 }))
  }

  return byDay
}

function computeEffectiveIntervalsForDate(args: {
  timeZone: string
  dateISO: string
  weekday: number
  baseByDay: Map<number, Interval[]>
  overridesByDate: Map<string, OverrideDTO[]>
}) {
  const base = args.baseByDay.get(args.weekday) ?? []
  const overrides = args.overridesByDate.get(args.dateISO) ?? []

  const adds: Interval[] = []
  const removes: Interval[] = []

  for (const override of overrides) {
    const local = overrideToLocalIntervalForDate(override, args.dateISO, args.timeZone)
    if (!local) continue
    if (override.kind === "AVAILABLE") adds.push(local)
    else removes.push(local)
  }

  const withAdds = unionIntervals(base, adds, { minSize: 1 })
  const effective = subtractIntervals(withAdds, removes, { minSize: 1 })
  return normalizeIntervals(effective, { minSize: 1 })
}

function isUserAvailableForUtcInterval(args: {
  startAtUtcISO: string
  endAtUtcISO: string
  userId: string
  timeZone: string
  baseByDay: Map<number, Interval[]>
  overridesByDate: Map<string, OverrideDTO[]>
  effectiveCache: Map<string, Interval[]>
}) {
  const startLocal = DateTime.fromISO(args.startAtUtcISO, { zone: "utc" }).setZone(args.timeZone)
  const endLocal = DateTime.fromISO(args.endAtUtcISO, { zone: "utc" }).setZone(args.timeZone)

  const startDate = startLocal.toISODate()
  const endDate = endLocal.toISODate()
  if (!startDate || !endDate || startDate !== endDate) return { ok: false }

  const weekday = startLocal.weekday
  const startMinute = minutesSinceStartOfDay(startLocal)
  const endMinute = minutesSinceStartOfDay(endLocal)

  const cacheKey = `${args.userId}|${startDate}`
  let effective = args.effectiveCache.get(cacheKey)
  if (!effective) {
    effective = computeEffectiveIntervalsForDate({
      timeZone: args.timeZone,
      dateISO: startDate,
      weekday,
      baseByDay: args.baseByDay,
      overridesByDate: args.overridesByDate,
    })
    args.effectiveCache.set(cacheKey, effective)
  }

  const covers = effective.some((interval) => interval.start <= startMinute && interval.end >= endMinute)

  return {
    ok: true as const,
    startMinute,
    endMinute,
    startLocal,
    endLocal,
    covers,
  }
}

export function generateSuggestions(input: GenerateSuggestionsInput): SuggestionCandidate[] {
  const maxCandidates = input.maxCandidates ?? 25

  const preparedAttendees = input.attendees.map((attendee) => ({
    ...attendee,
    baseByDay: buildWindowsByDay(attendee.windows),
    overridesByDate: indexOverridesByLocalDate(attendee.timeZone, attendee.overrides),
    effectiveCache: new Map<string, Interval[]>(),
  }))

  const startDay = DateTime.fromISO(input.rangeStart, { zone: input.timeZone }).startOf("day")
  const endDay = DateTime.fromISO(input.rangeEnd, { zone: input.timeZone }).startOf("day")

  const candidates: Omit<SuggestionCandidate, "rank">[] = []

  let cursor = startDay
  while (cursor <= endDay) {
    const dayEnd = cursor.plus({ minutes: input.dayEndMinute })

    for (let offset = input.dayStartMinute; offset + input.durationMinutes <= input.dayEndMinute; offset += input.stepMinutes) {
      const startLocal = cursor.plus({ minutes: offset })
      const endLocal = startLocal.plus({ minutes: input.durationMinutes })

      if (endLocal > dayEnd) continue
      if (!startLocal.isValid || !endLocal.isValid) continue

      const startAtUtcISO = startLocal.toUTC().toISO()
      const endAtUtcISO = endLocal.toUTC().toISO()
      if (!startAtUtcISO || !endAtUtcISO) continue

      const availableUserIds: string[] = []
      const missingUserIds: string[] = []

      const penalties: Array<{
        userId: string
        penalty: number
        startLocal: DateTime
        endLocal: DateTime
        tz: string
      }> = []

      for (const attendee of preparedAttendees) {
        const result = isUserAvailableForUtcInterval({
          startAtUtcISO,
          endAtUtcISO,
          userId: attendee.userId,
          timeZone: attendee.timeZone,
          baseByDay: attendee.baseByDay,
          overridesByDate: attendee.overridesByDate,
          effectiveCache: attendee.effectiveCache,
        })

        if (!result.ok || !result.covers) {
          missingUserIds.push(attendee.userId)
          continue
        }

        availableUserIds.push(attendee.userId)
        const penalty = penaltyForLocalInterval(result.startMinute, result.endMinute)
        penalties.push({
          userId: attendee.userId,
          penalty,
          startLocal: result.startLocal,
          endLocal: result.endLocal,
          tz: attendee.timeZone,
        })
      }

      const totalAttendees = preparedAttendees.length
      const attendanceRatio = totalAttendees === 0 ? 0 : availableUserIds.length / totalAttendees
      if (attendanceRatio <= 0) continue

      const attendanceScore = clamp01(attendanceRatio)
      const avgPenalty = penalties.length
        ? penalties.reduce((sum, item) => sum + item.penalty, 0) / penalties.length
        : 1
      const maxPenalty = penalties.length
        ? penalties.reduce((max, item) => Math.max(max, item.penalty), 0)
        : 1

      const inconvenienceScore = clamp01(1 - avgPenalty)
      const fairnessScore = clamp01(1 - maxPenalty)
      const totalScore = clamp01(0.6 * attendanceScore + 0.2 * inconvenienceScore + 0.2 * fairnessScore)

      const worst = penalties
        .slice()
        .sort((a, b) => b.penalty - a.penalty)[0]

      const why: string[] = []
      why.push(`${availableUserIds.length}/${totalAttendees} attendees available`)
      why.push(`Attendance score: ${attendanceScore.toFixed(2)}`)
      why.push(`Inconvenience score: ${inconvenienceScore.toFixed(2)}`)
      why.push(`Fairness score: ${fairnessScore.toFixed(2)}`)
      if (worst) {
        why.push(`Worst local time: ${worst.startLocal.toFormat("t")}–${worst.endLocal.toFormat("t")} (${worst.tz})`)
      }

      candidates.push({
        startAt: startAtUtcISO,
        endAt: endAtUtcISO,
        attendanceRatio,
        score: {
          total: totalScore,
          attendance: attendanceScore,
          inconvenience: inconvenienceScore,
          fairness: fairnessScore,
        },
        availableUserIds,
        missingUserIds,
        explanation: {
          why,
          worstLocalTime: worst
            ? {
                userId: worst.userId,
                localStart: worst.startLocal.toISO() ?? "",
                localEnd: worst.endLocal.toISO() ?? "",
                timeZone: worst.tz,
                penalty: worst.penalty,
              }
            : undefined,
        },
      })
    }

    cursor = cursor.plus({ days: 1 })
  }

  const ranked = candidates
    .sort((a, b) => {
      if (b.score.total !== a.score.total) return b.score.total - a.score.total
      if (b.score.attendance !== a.score.attendance) return b.score.attendance - a.score.attendance
      if (b.score.fairness !== a.score.fairness) return b.score.fairness - a.score.fairness
      return a.startAt.localeCompare(b.startAt)
    })
    .slice(0, maxCandidates)
    .map((candidate, index) => ({ ...candidate, rank: index + 1 }))

  return ranked
}
</file>

<file path="apps/web/src/lib/suggestions/state.ts">
import { createHash } from "crypto";

import { prisma } from "@lattice/db";
import type {
  AvailabilityTemplate,
  AvailabilityWindow,
  AvailabilityOverride,
  BusyBlock,
} from "@prisma/client";
import { generateDemoBusyBlocks } from "./demo-busy";

type TemplateWithWindows = AvailabilityTemplate & {
  windows: AvailabilityWindow[];
};

export type SuggestionAvailabilityState = {
  templates: TemplateWithWindows[];
  overrides: AvailabilityOverride[];
  busyBlocks: Array<Pick<BusyBlock, "userId" | "startUtc" | "endUtc" | "createdAt">>;
  dataFingerprint: string;
};

export async function loadSuggestionAvailabilityState(params: {
  orgId: string;
  attendeeUserIds: string[];
  rangeStart: Date;
  rangeEnd: Date;
}): Promise<SuggestionAvailabilityState> {
  const [templates, overrides, busyBlocks, calendarConnections] = await Promise.all([
    prisma.availabilityTemplate.findMany({
      where: {
        orgId: params.orgId,
        userId: { in: params.attendeeUserIds },
      },
      include: { windows: true },
    }),
    prisma.availabilityOverride.findMany({
      where: {
        orgId: params.orgId,
        userId: { in: params.attendeeUserIds },
        startAt: { lt: params.rangeEnd },
        endAt: { gt: params.rangeStart },
      },
      orderBy: { startAt: "asc" },
    }),
    prisma.busyBlock.findMany({
      where: {
        orgId: params.orgId,
        userId: { in: params.attendeeUserIds },
        provider: "GOOGLE",
        startUtc: { lt: params.rangeEnd },
        endUtc: { gt: params.rangeStart },
      },
      orderBy: { startUtc: "asc" },
      select: { userId: true, startUtc: true, endUtc: true, createdAt: true },
    }),
    prisma.calendarConnection.findMany({
      where: {
        userId: { in: params.attendeeUserIds },
        provider: "GOOGLE",
        status: "ACTIVE",
      },
      select: { userId: true },
    }),
  ]);

  const availabilityVersionByUser = buildAvailabilityVersionMap(templates, overrides);
  const fallbackBlocks = buildDemoFallbackBlocks(params, busyBlocks, calendarConnections);
  const allBusyBlocks = [...busyBlocks, ...fallbackBlocks].sort(
    (a, b) => a.startUtc.getTime() - b.startUtc.getTime(),
  );
  const busyVersionByUser = buildBusyVersionMap(allBusyBlocks);
  const dataFingerprint = computeDataFingerprint(
    params.attendeeUserIds,
    availabilityVersionByUser,
    busyVersionByUser,
  );

  return {
    templates,
    overrides,
    busyBlocks: allBusyBlocks,
    dataFingerprint,
  };
}

function buildAvailabilityVersionMap(
  templates: TemplateWithWindows[],
  overrides: AvailabilityOverride[],
) {
  const map = new Map<string, Date>();
  for (const template of templates) {
    const existing = map.get(template.userId);
    if (!existing || template.updatedAt > existing) {
      map.set(template.userId, template.updatedAt);
    }
  }
  for (const override of overrides) {
    const existing = map.get(override.userId);
    if (!existing || override.updatedAt > existing) {
      map.set(override.userId, override.updatedAt);
    }
  }
  return map;
}

function buildBusyVersionMap(busyBlocks: Array<Pick<BusyBlock, "userId" | "createdAt">>) {
  const map = new Map<string, Date>();
  for (const block of busyBlocks) {
    const existing = map.get(block.userId);
    if (!existing || block.createdAt > existing) {
      map.set(block.userId, block.createdAt);
    }
  }
  return map;
}

function computeDataFingerprint(
  attendeeUserIds: string[],
  availabilityVersionByUser: Map<string, Date>,
  busyVersionByUser: Map<string, Date>,
) {
  const segments = attendeeUserIds.map((userId) => {
    const availability = availabilityVersionByUser.get(userId);
    const busy = busyVersionByUser.get(userId);
    return `${userId}:${availability?.toISOString() ?? "none"}:${busy?.toISOString() ?? "none"}`;
  });
  return createHash("sha256").update(segments.join("|")).digest("hex");
}

function buildDemoFallbackBlocks(
  params: Parameters<typeof loadSuggestionAvailabilityState>[0],
  existingBusyBlocks: Array<Pick<BusyBlock, "userId" | "startUtc" | "endUtc" | "createdAt">>,
  calendarConnections: Array<{ userId: string }>,
): Array<Pick<BusyBlock, "userId" | "startUtc" | "endUtc" | "createdAt">> {
  const connectedUsers = new Set(calendarConnections.map((connection) => connection.userId));
  const usersWithBusy = new Set(existingBusyBlocks.map((block) => block.userId));

  return params.attendeeUserIds.flatMap((userId) => {
    if (connectedUsers.has(userId) || usersWithBusy.has(userId)) {
      return [];
    }
    return generateDemoBusyBlocks({
      userId,
      rangeStart: params.rangeStart,
      rangeEnd: params.rangeEnd,
    });
  });
}
</file>

<file path="apps/web/src/lib/env.ts">
import { parseEnv } from "@lattice/shared";

export const env = parseEnv(process.env as Record<string, string | undefined>);
</file>

<file path="apps/web/src/lib/http.ts">
import type { ErrorCode } from "@lattice/shared";

export class ApiError extends Error {
  public readonly status: number;
  public readonly code?: ErrorCode;
  public readonly details?: unknown;

  constructor(message: string, status: number, code?: ErrorCode, details?: unknown) {
    super(message);
    this.name = "ApiError";
    this.status = status;
    this.code = code;
    this.details = details;
  }
}

export async function fetchJson<T>(input: RequestInfo | URL, init?: RequestInit) {
  const response = await fetch(input, init);
  const payload = await response.json().catch(() => null);
  const error = payload?.error;

  if (error) {
    throw new ApiError(
      error.message ?? "Request failed",
      response.status,
      error.code,
      error.details
    );
  }

  if (!response.ok) {
    throw new ApiError("Request failed", response.status);
  }

  return (payload?.data ?? null) as T;
}
</file>

<file path="apps/web/src/lib/openapi.ts">
import path from "node:path";
import swaggerJSDoc, { type Options } from "swagger-jsdoc";

const swaggerOptions: Options = {
  definition: {
    openapi: "3.1.0",
    info: {
      title: "Lattice API",
      version: "1.0.0",
      description: "Privacy-respecting group scheduling endpoints powering the Lattice web client.",
    },
    servers: [
      {
        url: process.env.NEXT_PUBLIC_APP_URL ?? "/",
      },
    ],
  },
  apis: [
    path.resolve(process.cwd(), "src/app/api/**/*.ts"),
    path.resolve(process.cwd(), "src/app/api/**/*.tsx"),
  ],
};

let cachedSpec: ReturnType<typeof swaggerJSDoc> | null = null;

export function getOpenApiSpec() {
  if (!cachedSpec || process.env.NODE_ENV === "development") {
    cachedSpec = swaggerJSDoc(swaggerOptions);
  }
  return cachedSpec;
}
</file>

<file path="apps/web/src/lib/org-context.ts">
import { cookies } from "next/headers";

export const ACTIVE_ORG_COOKIE = "lattice_org";

export async function getActiveOrgId(): Promise<string | null> {
  const cookieStore = await cookies();
  return cookieStore.get(ACTIVE_ORG_COOKIE)?.value ?? null;
}

export async function setActiveOrgId(orgId: string) {
  const cookieStore = await cookies();
  cookieStore.set(ACTIVE_ORG_COOKIE, orgId, {
    httpOnly: true,
    sameSite: "lax",
    secure: process.env.NODE_ENV === "production",
    path: "/",
  });
}
</file>

<file path="apps/web/src/lib/rbac.ts">
export type OrgRole = "OWNER" | "ADMIN" | "LEADER" | "MEMBER";

const ROLE_RANK: Record<OrgRole, number> = {
  MEMBER: 0,
  LEADER: 1,
  ADMIN: 2,
  OWNER: 3,
};

export function roleAtLeast(actual: OrgRole, required: OrgRole) {
  return ROLE_RANK[actual] >= ROLE_RANK[required];
}

export function isOrgAdmin(role: OrgRole) {
  return role === "OWNER" || role === "ADMIN";
}
</file>

<file path="apps/web/src/lib/slugify.ts">
export function slugify(input: string) {
  return input
    .toLowerCase()
    .trim()
    .replace(/['"]/g, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "")
    .slice(0, 48);
}
</file>

<file path="apps/web/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="apps/web/src/types/next-auth.d.ts">
import "next-auth";

declare module "next-auth" {
  interface Session {
    user?: {
      id: string;
      name?: string | null;
      email?: string | null;
      image?: string | null;
    };
  }
}

export {};
</file>

<file path="apps/web/tests/e2e/auth-smoke.spec.ts">
import { test, expect } from "@playwright/test";

test("dev sign-in reaches dashboard", async ({ page }) => {
  await page.goto("http://localhost:3000/signin");
  await page.getByLabel("Email (dev/test)").fill("dev@example.com");
  await page
    .getByRole("button", { name: "Continue", exact: true })
    .click();

  await expect(page.getByRole("heading", { name: "Dashboard" })).toBeVisible();
});
</file>

<file path="apps/web/tests/e2e/availability.spec.ts">
import { test, expect } from "@playwright/test";
import {
  uniqueOrgName,
  signInAndCreateOrg,
  goToAvailability,
  configureWeeklyAvailability,
  createAvailabilityOverride,
} from "./helpers/demo-flow";

test("configures a weekly template with an override", async ({ page }) => {
  const orgName = uniqueOrgName("Availability Org");
  await signInAndCreateOrg(page, orgName);
  await goToAvailability(page);
  await configureWeeklyAvailability(page);

  const overrideNote = `Playwright block ${Date.now()}`;
  await createAvailabilityOverride(page, { note: overrideNote });

  await expect(page.getByText(overrideNote)).toBeVisible();
  await expect(page.getByRole("heading", { name: "Effective availability preview" })).toBeVisible();
});
</file>

<file path="apps/web/tests/e2e/confirm.spec.ts">
import { test, expect } from "@playwright/test";
import {
  uniqueOrgName,
  signInAndCreateOrg,
  goToAvailability,
  configureWeeklyAvailability,
  createAvailabilityOverride,
  goToSuggestions,
  createSuggestionRequest,
} from "./helpers/demo-flow";

test("confirms a suggestion and shows the scheduled event", async ({ page }) => {
  const orgName = uniqueOrgName("Confirm Org");
  const requestTitle = `Playwright confirm ${Date.now()}`;

  await signInAndCreateOrg(page, orgName);
  await goToAvailability(page);
  await configureWeeklyAvailability(page);
  await createAvailabilityOverride(page, { note: "Confirm override" });

  await goToSuggestions(page);
  const { first: topCandidate } = await createSuggestionRequest(page, requestTitle);
  const confirmButton = topCandidate.getByRole("button", { name: "Confirm this slot" });

  await Promise.all([
    page.waitForURL(/\/events\/[^/]+$/),
    confirmButton.click(),
  ]);

  await expect(page.getByRole("heading", { name: requestTitle })).toBeVisible();
  await expect(page.getByText("Time:")).toBeVisible();
  await expect(page.getByRole("heading", { name: "Attendees" })).toBeVisible();
});
</file>

<file path="apps/web/tests/e2e/home.spec.ts">
import { test, expect } from "@playwright/test";

test("home loads", async ({ page }) => {
  await page.goto("http://localhost:3000/");
  await expect(page.getByRole("heading", { name: "Lattice" })).toBeVisible();
});
</file>

<file path="apps/web/tests/e2e/suggestions.spec.ts">
import { test, expect } from "@playwright/test";
import {
  uniqueOrgName,
  signInAndCreateOrg,
  goToAvailability,
  configureWeeklyAvailability,
  createAvailabilityOverride,
  goToSuggestions,
  createSuggestionRequest,
} from "./helpers/demo-flow";

test("creates a suggestion request and shows the explanation", async ({ page }) => {
  const orgName = uniqueOrgName("Suggestions Org");
  const requestTitle = `Playwright request ${Date.now()}`;

  await signInAndCreateOrg(page, orgName);
  await goToAvailability(page);
  await configureWeeklyAvailability(page);
  await createAvailabilityOverride(page, { note: "Phase-2 override" });

  await goToSuggestions(page);
  const { first: topCandidate } = await createSuggestionRequest(page, requestTitle);

  await expect(topCandidate).toContainText("attendees available");
  await expect(topCandidate.getByRole("button", { name: "Confirm this slot" })).toBeVisible();
});
</file>

<file path="apps/web/tests/unit/openapi.test.ts">
import { describe, expect, it } from "vitest";

import { GET as getOpenApi } from "@/app/api/openapi/route";

describe("OpenAPI route", () => {
  it("returns a document that defines the API", async () => {
    const response = await getOpenApi();
    expect(response.status).toBe(200);

    const spec = await response.json();
    expect(spec).toHaveProperty("openapi");
    expect(spec.openapi).toMatch(/^3\./);
    expect(spec).toHaveProperty("info");
    expect(spec.paths).toHaveProperty("/api/health");
    expect(spec.paths).toHaveProperty("/api/orgs");
  });
});
</file>

<file path="apps/web/tests/unit/rbac.test.ts">
import { describe, expect, it } from "vitest";
import { roleAtLeast } from "@/lib/rbac";

describe("roleAtLeast", () => {
  it("orders roles correctly", () => {
    expect(roleAtLeast("OWNER", "ADMIN")).toBe(true);
    expect(roleAtLeast("ADMIN", "OWNER")).toBe(false);
    expect(roleAtLeast("LEADER", "MEMBER")).toBe(true);
    expect(roleAtLeast("MEMBER", "LEADER")).toBe(false);
  });
});
</file>

<file path="apps/web/tests/unit/smoke.test.ts">
import { expect, test } from "vitest";

test("smoke", () => {
  expect(1 + 1).toBe(2);
});
</file>

<file path="apps/web/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="apps/web/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}
</file>

<file path="apps/web/eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="apps/web/postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="apps/web/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="apps/web/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "src/**/*.ts",
    "src/**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="apps/web/vitest.config.ts">
import { defineConfig } from "vitest/config";
import { resolve } from "path";

export default defineConfig({
  resolve: {
    alias: {
      "@/": resolve(__dirname, "src") + "/",
    },
  },
  test: {
    environment: "node",
    include: [
      "src/**/*.test.{ts,tsx}",
      "tests/unit/**/*.test.{ts,tsx}",
    ],
    exclude: ["tests/e2e/**"],
  },
});
</file>

<file path="docs/adr/0001-template.md">
# ADR-0001: (Title)

## Status
Proposed | Accepted | Deprecated | Superseded

## Context
What problem are we solving?

## Decision
What did we decide?

## Consequences
Trade-offs, risks, follow-ups.
</file>

<file path="docs/api.md">
# API Notes

## Conventions
- JSON responses
- Error shape: `{ error: { code, message } }`
- Idempotency: reserved for later phases (Redis)

## Starter routes
- `GET /api/health`
- `GET /api/db-ping`

## Suggestions (Phase 3)

> Requires `SUGGESTIONS_ENABLED=1` to be set in the environment.

- `POST /api/orgs/:orgId/suggestions/requests` — create a request and generate ranked candidate slots.
- `GET /api/orgs/:orgId/suggestions/requests` — list recent suggestion requests for an org.
- `GET /api/orgs/:orgId/suggestions/requests/:requestId` — fetch a single request with its candidates/explanation payload.
</file>

<file path="docs/architecture.md">
# Architecture

## High-level
- Next.js App Router
- Route Handlers for API
- Postgres (Neon in prod)
- Redis (Upstash in prod)

## Packages
- apps/web
- packages/db
- packages/shared

## Notes
- Phase 1 adds Auth.js and org-scoped authorization.
- Phase 2 adds calendar integrations and availability normalization.
</file>

<file path="docs/fairness-engine.md">
# Fairness Engine (Phase 3)

v1 uses a simple, deterministic fairness proxy:
- compute a local-time penalty for each available attendee
- fairness score = 1 - maxPenalty

This avoids recommending slots that are great for most but punishing for one person.

Future phases can replace this with rolling 30-day burden budgets once we have scheduled events.
</file>

<file path="docs/threat-model.md">
# Threat Model (starter)

## Assets
- User identities
- Calendar metadata + tokens
- Availability profiles

## Threats
- Unauthorized org data access (multi-tenant isolation)
- Token leakage
- Excessive calendar permissions

## Mitigations (Phase 0/1)
- Org-scoped authorization checks
- Env/secret hygiene
- Minimal OAuth scopes
- Reduce logging of sensitive payloads
</file>

<file path="packages/db/prisma/migrations/20260105215837_init/migration.sql">
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('OWNER', 'ADMIN', 'LEADER', 'MEMBER');

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "name" TEXT,
    "email" TEXT,
    "emailVerified" TIMESTAMP(3),
    "image" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Account" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "provider" TEXT NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "refresh_token" TEXT,
    "access_token" TEXT,
    "expires_at" INTEGER,
    "token_type" TEXT,
    "scope" TEXT,
    "id_token" TEXT,
    "session_state" TEXT,

    CONSTRAINT "Account_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Session" (
    "id" TEXT NOT NULL,
    "sessionToken" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Session_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "VerificationToken" (
    "identifier" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL
);

-- CreateTable
CREATE TABLE "Org" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "slug" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Org_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Membership" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'MEMBER',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Membership_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Account_provider_providerAccountId_key" ON "Account"("provider", "providerAccountId");

-- CreateIndex
CREATE UNIQUE INDEX "Session_sessionToken_key" ON "Session"("sessionToken");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_token_key" ON "VerificationToken"("token");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_identifier_token_key" ON "VerificationToken"("identifier", "token");

-- CreateIndex
CREATE UNIQUE INDEX "Org_slug_key" ON "Org"("slug");

-- CreateIndex
CREATE UNIQUE INDEX "Membership_orgId_userId_key" ON "Membership"("orgId", "userId");

-- AddForeignKey
ALTER TABLE "Account" ADD CONSTRAINT "Account_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Session" ADD CONSTRAINT "Session_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Membership" ADD CONSTRAINT "Membership_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Membership" ADD CONSTRAINT "Membership_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="packages/db/prisma/migrations/20260106000452_availability_profiles/migration.sql">
-- CreateEnum
CREATE TYPE "AvailabilityOverrideKind" AS ENUM ('AVAILABLE', 'UNAVAILABLE');

-- CreateTable
CREATE TABLE "AvailabilityTemplate" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "timeZone" TEXT NOT NULL DEFAULT 'UTC',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "AvailabilityTemplate_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "AvailabilityWindow" (
    "id" TEXT NOT NULL,
    "templateId" TEXT NOT NULL,
    "dayOfWeek" INTEGER NOT NULL,
    "startMinute" INTEGER NOT NULL,
    "endMinute" INTEGER NOT NULL,

    CONSTRAINT "AvailabilityWindow_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "AvailabilityOverride" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "startAt" TIMESTAMP(3) NOT NULL,
    "endAt" TIMESTAMP(3) NOT NULL,
    "kind" "AvailabilityOverrideKind" NOT NULL,
    "note" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "AvailabilityOverride_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "AvailabilityTemplate_orgId_idx" ON "AvailabilityTemplate"("orgId");

-- CreateIndex
CREATE INDEX "AvailabilityTemplate_userId_idx" ON "AvailabilityTemplate"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "AvailabilityTemplate_orgId_userId_key" ON "AvailabilityTemplate"("orgId", "userId");

-- CreateIndex
CREATE INDEX "AvailabilityWindow_templateId_idx" ON "AvailabilityWindow"("templateId");

-- CreateIndex
CREATE INDEX "AvailabilityWindow_dayOfWeek_idx" ON "AvailabilityWindow"("dayOfWeek");

-- CreateIndex
CREATE INDEX "AvailabilityOverride_orgId_startAt_idx" ON "AvailabilityOverride"("orgId", "startAt");

-- CreateIndex
CREATE INDEX "AvailabilityOverride_userId_startAt_idx" ON "AvailabilityOverride"("userId", "startAt");

-- CreateIndex
CREATE INDEX "AvailabilityOverride_orgId_userId_startAt_idx" ON "AvailabilityOverride"("orgId", "userId", "startAt");

-- AddForeignKey
ALTER TABLE "AvailabilityTemplate" ADD CONSTRAINT "AvailabilityTemplate_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "AvailabilityTemplate" ADD CONSTRAINT "AvailabilityTemplate_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "AvailabilityWindow" ADD CONSTRAINT "AvailabilityWindow_templateId_fkey" FOREIGN KEY ("templateId") REFERENCES "AvailabilityTemplate"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "AvailabilityOverride" ADD CONSTRAINT "AvailabilityOverride_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "AvailabilityOverride" ADD CONSTRAINT "AvailabilityOverride_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="packages/db/prisma/migrations/20260106020655_phase4_google_calendar/migration.sql">
-- CreateEnum
CREATE TYPE "CalendarProvider" AS ENUM ('GOOGLE');

-- CreateEnum
CREATE TYPE "CalendarConnectionStatus" AS ENUM ('ACTIVE', 'REVOKED', 'ERROR');

-- CreateTable
CREATE TABLE "CalendarConnection" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "provider" "CalendarProvider" NOT NULL,
    "scopes" TEXT NOT NULL,
    "encryptedRefreshToken" TEXT NOT NULL,
    "status" "CalendarConnectionStatus" NOT NULL DEFAULT 'ACTIVE',
    "lastSyncAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "CalendarConnection_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "CalendarSelection" (
    "id" TEXT NOT NULL,
    "connectionId" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "calendarIdHash" TEXT NOT NULL,
    "isBusySource" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "CalendarSelection_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "BusyBlock" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "provider" "CalendarProvider" NOT NULL,
    "sourceHash" TEXT NOT NULL,
    "startUtc" TIMESTAMP(3) NOT NULL,
    "endUtc" TIMESTAMP(3) NOT NULL,
    "blockHash" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "BusyBlock_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "CalendarSyncRun" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "connectionId" TEXT NOT NULL,
    "provider" "CalendarProvider" NOT NULL,
    "rangeStartUtc" TIMESTAMP(3) NOT NULL,
    "rangeEndUtc" TIMESTAMP(3) NOT NULL,
    "status" TEXT NOT NULL,
    "errorCode" TEXT,
    "errorDetail" TEXT,
    "startedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "finishedAt" TIMESTAMP(3),

    CONSTRAINT "CalendarSyncRun_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SuggestionRequest" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "createdById" TEXT NOT NULL,
    "requestKey" TEXT NOT NULL,
    "title" TEXT,
    "timeZone" TEXT NOT NULL,
    "rangeStart" TIMESTAMP(3) NOT NULL,
    "rangeEnd" TIMESTAMP(3) NOT NULL,
    "durationMinutes" INTEGER NOT NULL,
    "stepMinutes" INTEGER NOT NULL DEFAULT 15,
    "dayStartMinute" INTEGER NOT NULL DEFAULT 480,
    "dayEndMinute" INTEGER NOT NULL DEFAULT 1200,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "SuggestionRequest_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SuggestionRequestAttendee" (
    "id" TEXT NOT NULL,
    "requestId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "SuggestionRequestAttendee_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SuggestionCandidate" (
    "id" TEXT NOT NULL,
    "requestId" TEXT NOT NULL,
    "rank" INTEGER NOT NULL,
    "startAt" TIMESTAMP(3) NOT NULL,
    "endAt" TIMESTAMP(3) NOT NULL,
    "attendanceRatio" DOUBLE PRECISION NOT NULL,
    "scoreTotal" DOUBLE PRECISION NOT NULL,
    "scoreAttendance" DOUBLE PRECISION NOT NULL,
    "scoreInconvenience" DOUBLE PRECISION NOT NULL,
    "scoreFairness" DOUBLE PRECISION NOT NULL,
    "availableUserIds" TEXT[],
    "missingUserIds" TEXT[],
    "explanation" JSONB NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "SuggestionCandidate_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "CalendarConnection_userId_provider_key" ON "CalendarConnection"("userId", "provider");

-- CreateIndex
CREATE UNIQUE INDEX "CalendarSelection_connectionId_orgId_calendarIdHash_key" ON "CalendarSelection"("connectionId", "orgId", "calendarIdHash");

-- CreateIndex
CREATE UNIQUE INDEX "BusyBlock_blockHash_key" ON "BusyBlock"("blockHash");

-- CreateIndex
CREATE INDEX "BusyBlock_orgId_userId_startUtc_idx" ON "BusyBlock"("orgId", "userId", "startUtc");

-- CreateIndex
CREATE INDEX "CalendarSyncRun_orgId_userId_startedAt_idx" ON "CalendarSyncRun"("orgId", "userId", "startedAt");

-- CreateIndex
CREATE INDEX "SuggestionRequest_orgId_createdAt_idx" ON "SuggestionRequest"("orgId", "createdAt");

-- CreateIndex
CREATE UNIQUE INDEX "SuggestionRequest_orgId_requestKey_key" ON "SuggestionRequest"("orgId", "requestKey");

-- CreateIndex
CREATE INDEX "SuggestionRequestAttendee_userId_idx" ON "SuggestionRequestAttendee"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "SuggestionRequestAttendee_requestId_userId_key" ON "SuggestionRequestAttendee"("requestId", "userId");

-- CreateIndex
CREATE INDEX "SuggestionCandidate_requestId_rank_idx" ON "SuggestionCandidate"("requestId", "rank");

-- CreateIndex
CREATE INDEX "SuggestionCandidate_startAt_idx" ON "SuggestionCandidate"("startAt");

-- AddForeignKey
ALTER TABLE "CalendarConnection" ADD CONSTRAINT "CalendarConnection_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CalendarSelection" ADD CONSTRAINT "CalendarSelection_connectionId_fkey" FOREIGN KEY ("connectionId") REFERENCES "CalendarConnection"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CalendarSelection" ADD CONSTRAINT "CalendarSelection_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BusyBlock" ADD CONSTRAINT "BusyBlock_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BusyBlock" ADD CONSTRAINT "BusyBlock_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CalendarSyncRun" ADD CONSTRAINT "CalendarSyncRun_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CalendarSyncRun" ADD CONSTRAINT "CalendarSyncRun_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CalendarSyncRun" ADD CONSTRAINT "CalendarSyncRun_connectionId_fkey" FOREIGN KEY ("connectionId") REFERENCES "CalendarConnection"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SuggestionRequest" ADD CONSTRAINT "SuggestionRequest_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SuggestionRequest" ADD CONSTRAINT "SuggestionRequest_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SuggestionRequestAttendee" ADD CONSTRAINT "SuggestionRequestAttendee_requestId_fkey" FOREIGN KEY ("requestId") REFERENCES "SuggestionRequest"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SuggestionRequestAttendee" ADD CONSTRAINT "SuggestionRequestAttendee_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SuggestionCandidate" ADD CONSTRAINT "SuggestionCandidate_requestId_fkey" FOREIGN KEY ("requestId") REFERENCES "SuggestionRequest"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="packages/db/prisma/migrations/20260106031037_phase5_scheduled_events/migration.sql">
-- CreateEnum
CREATE TYPE "ScheduledEventStatus" AS ENUM ('CONFIRMED', 'CANCELLED');

-- CreateEnum
CREATE TYPE "RsvpStatus" AS ENUM ('INVITED', 'ACCEPTED', 'DECLINED', 'TENTATIVE');

-- CreateEnum
CREATE TYPE "WriteBackStatus" AS ENUM ('NOT_REQUESTED', 'PENDING', 'SUCCESS', 'ERROR');

-- CreateTable
CREATE TABLE "ScheduledEvent" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "notes" TEXT,
    "startUtc" TIMESTAMP(3) NOT NULL,
    "endUtc" TIMESTAMP(3) NOT NULL,
    "timeZone" TEXT NOT NULL,
    "status" "ScheduledEventStatus" NOT NULL DEFAULT 'CONFIRMED',
    "sourceRequestId" TEXT,
    "sourceCandidateRank" INTEGER,
    "createdById" TEXT NOT NULL,
    "confirmedById" TEXT NOT NULL,
    "writeBackStatus" "WriteBackStatus" NOT NULL DEFAULT 'NOT_REQUESTED',
    "externalProvider" TEXT,
    "externalCalendarId" TEXT,
    "externalEventId" TEXT,
    "externalEventHtmlLink" TEXT,
    "writeBackError" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "ScheduledEvent_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ScheduledEventAttendee" (
    "id" TEXT NOT NULL,
    "eventId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "rsvp" "RsvpStatus" NOT NULL DEFAULT 'INVITED',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "ScheduledEventAttendee_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "ScheduledEvent_orgId_startUtc_idx" ON "ScheduledEvent"("orgId", "startUtc");

-- CreateIndex
CREATE UNIQUE INDEX "ScheduledEvent_sourceRequestId_sourceCandidateRank_key" ON "ScheduledEvent"("sourceRequestId", "sourceCandidateRank");

-- CreateIndex
CREATE INDEX "ScheduledEventAttendee_userId_idx" ON "ScheduledEventAttendee"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "ScheduledEventAttendee_eventId_userId_key" ON "ScheduledEventAttendee"("eventId", "userId");

-- AddForeignKey
ALTER TABLE "ScheduledEvent" ADD CONSTRAINT "ScheduledEvent_orgId_fkey" FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ScheduledEvent" ADD CONSTRAINT "ScheduledEvent_sourceRequestId_fkey" FOREIGN KEY ("sourceRequestId") REFERENCES "SuggestionRequest"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ScheduledEvent" ADD CONSTRAINT "ScheduledEvent_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ScheduledEvent" ADD CONSTRAINT "ScheduledEvent_confirmedById_fkey" FOREIGN KEY ("confirmedById") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ScheduledEventAttendee" ADD CONSTRAINT "ScheduledEventAttendee_eventId_fkey" FOREIGN KEY ("eventId") REFERENCES "ScheduledEvent"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ScheduledEventAttendee" ADD CONSTRAINT "ScheduledEventAttendee_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="packages/db/prisma/migrations/20260106120000_phase5_idempotency/migration.sql">
-- Drop this file and rerun `pnpm prisma migrate dev` if the schema drift deviates.
-- Added Phase 5 idempotency tracking.
ALTER TABLE "SuggestionRequest"
ADD COLUMN "dataFingerprint" TEXT;

CREATE TABLE "IdempotencyKey" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "key" TEXT NOT NULL,
    "endpoint" TEXT NOT NULL,
    "requestHash" TEXT NOT NULL,
    "responseStatus" INTEGER,
    "responseBody" JSONB,
    "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    "expiresAt" TIMESTAMPTZ NOT NULL,
    PRIMARY KEY ("id")
);

ALTER TABLE "IdempotencyKey"
ADD CONSTRAINT "IdempotencyKey_orgId_fkey"
FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;

CREATE UNIQUE INDEX "IdempotencyKey_orgId_endpoint_key_key" ON "IdempotencyKey"("orgId","endpoint","key");
CREATE INDEX "IdempotencyKey_expiresAt_idx" ON "IdempotencyKey"("expiresAt");
</file>

<file path="packages/db/prisma/migrations/20260106123000_phase6a_audit_logs/migration.sql">
-- Added Phase 6A audit logging.
CREATE TYPE "AuditAction" AS ENUM (
    'ORG_CREATED',
    'MEMBER_INVITED',
    'MEMBER_ROLE_UPDATED',
    'MEMBER_REMOVED',
    'AVAILABILITY_TEMPLATE_UPDATED',
    'AVAILABILITY_OVERRIDE_CREATED',
    'AVAILABILITY_OVERRIDE_DELETED',
    'CALENDAR_CONNECTED',
    'CALENDAR_DISCONNECTED',
    'CALENDAR_SYNC_STARTED',
    'CALENDAR_SYNC_SUCCESS',
    'CALENDAR_SYNC_FAILURE',
    'SUGGESTION_REQUEST_CREATED',
    'SLOT_CONFIRMED',
    'WRITEBACK_ATTEMPTED',
    'ACCEPTANCE_CHECK'
);

CREATE TABLE "AuditLog" (
    "id" TEXT NOT NULL,
    "orgId" TEXT NOT NULL,
    "actorUserId" TEXT,
    "action" "AuditAction" NOT NULL,
    "targetType" TEXT,
    "targetId" TEXT,
    "metadata" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "AuditLog_pkey" PRIMARY KEY ("id")
);

CREATE INDEX "AuditLog_orgId_createdAt_idx" ON "AuditLog"("orgId","createdAt");
CREATE INDEX "AuditLog_orgId_action_createdAt_idx" ON "AuditLog"("orgId","action","createdAt");

ALTER TABLE "AuditLog"
ADD CONSTRAINT "AuditLog_orgId_fkey"
FOREIGN KEY ("orgId") REFERENCES "Org"("id") ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE "AuditLog"
ADD CONSTRAINT "AuditLog_actorUserId_fkey"
FOREIGN KEY ("actorUserId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="packages/db/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="packages/db/prisma/seed.ts">
import { createHash } from "crypto";
import {
  PrismaClient,
  CalendarProvider,
  AvailabilityOverrideKind,
  Role,
} from "@prisma/client";

const prisma = new PrismaClient();

const DEMO_ORG_SLUG = "demo";
const DEMO_ORG_NAME = "Lattice Demo";

type DemoUser = {
  key: "leader" | "memberA" | "memberB";
  email: string;
  name: string;
  role: Role;
  timeZone: string;
};

const DEMO_USERS: DemoUser[] = [
  {
    key: "leader",
    email: "demo.leader@lattice.local",
    name: "Demo Leader",
    role: Role.LEADER,
    timeZone: "America/Los_Angeles",
  },
  {
    key: "memberA",
    email: "demo.member-a@lattice.local",
    name: "Demo Member A",
    role: Role.MEMBER,
    timeZone: "America/New_York",
  },
  {
    key: "memberB",
    email: "demo.member-b@lattice.local",
    name: "Demo Member B",
    role: Role.MEMBER,
    timeZone: "Europe/London",
  },
];

type WindowPattern = { dayOfWeek: number; startMinute: number; endMinute: number };

const AVAILABILITY_WINDOWS: Record<DemoUser["key"], WindowPattern[]> = {
  leader: [
    { dayOfWeek: 1, startMinute: 8 * 60, endMinute: 12 * 60 },
    { dayOfWeek: 1, startMinute: 13 * 60, endMinute: 17 * 60 },
    { dayOfWeek: 2, startMinute: 9 * 60, endMinute: 16 * 60 },
    { dayOfWeek: 4, startMinute: 7 * 60 + 30, endMinute: 15 * 60 },
  ],
  memberA: [
    { dayOfWeek: 1, startMinute: 7 * 60 + 30, endMinute: 11 * 60 },
    { dayOfWeek: 3, startMinute: 12 * 60, endMinute: 18 * 60 },
    { dayOfWeek: 5, startMinute: 8 * 60, endMinute: 14 * 60 },
  ],
  memberB: [
    { dayOfWeek: 2, startMinute: 10 * 60, endMinute: 17 * 60 },
    { dayOfWeek: 4, startMinute: 9 * 60, endMinute: 12 * 60 },
    { dayOfWeek: 5, startMinute: 13 * 60, endMinute: 18 * 60 },
  ],
};

const BUSY_PATTERNS: Record<
  DemoUser["key"],
  Array<{ dayOffset: number; startMinute: number; durationMinutes: number }>
> = {
  leader: [
    { dayOffset: 0, startMinute: 9 * 60, durationMinutes: 75 },
    { dayOffset: 1, startMinute: 11 * 60 + 15, durationMinutes: 45 },
    { dayOffset: 3, startMinute: 15 * 60, durationMinutes: 60 },
  ],
  memberA: [
    { dayOffset: 0, startMinute: 10 * 60, durationMinutes: 60 },
    { dayOffset: 2, startMinute: 13 * 60, durationMinutes: 90 },
    { dayOffset: 4, startMinute: 9 * 60, durationMinutes: 90 },
  ],
  memberB: [
    { dayOffset: 1, startMinute: 8 * 60 + 30, durationMinutes: 60 },
    { dayOffset: 3, startMinute: 12 * 60, durationMinutes: 120 },
    { dayOffset: 4, startMinute: 14 * 60, durationMinutes: 75 },
  ],
};

function getMondayOfCurrentWeek(): Date {
  const now = new Date();
  const utcDay = now.getUTCDay(); // 0=Sun, 1=Mon ... 6=Sat
  const mondayOffset = utcDay === 0 ? -6 : 1 - utcDay;
  const monday = new Date(now);
  monday.setUTCDate(now.getUTCDate() + mondayOffset);
  monday.setUTCHours(0, 0, 0, 0);
  return monday;
}

function addDays(date: Date, days: number): Date {
  const next = new Date(date);
  next.setUTCDate(date.getUTCDate() + days);
  return next;
}

function addMinutes(date: Date, minutes: number): Date {
  return new Date(date.getTime() + minutes * 60 * 1000);
}

function computeBlockHash({
  orgId,
  userId,
  sourceHash,
  start,
  end,
}: {
  orgId: string;
  userId: string;
  sourceHash: string;
  start: Date;
  end: Date;
}) {
  return createHash("sha256")
    .update(`${orgId}|${userId}|${sourceHash}|${start.toISOString()}|${end.toISOString()}`)
    .digest("hex");
}

function buildBusyBlockArgs({
  orgId,
  userId,
  pattern,
  patternIndex,
}: {
  orgId: string;
  userId: string;
  pattern: { dayOffset: number; startMinute: number; durationMinutes: number };
  patternIndex: number;
}) {
  const weekStart = getMondayOfCurrentWeek();
  const dayStart = addDays(weekStart, pattern.dayOffset);
  const start = addMinutes(dayStart, pattern.startMinute);
  const end = addMinutes(start, pattern.durationMinutes);
  const sourceHash = `demo:${userId}:${patternIndex}`;
  return {
    orgId,
    userId,
    provider: CalendarProvider.GOOGLE,
    sourceHash,
    startUtc: start,
    endUtc: end,
    blockHash: computeBlockHash({
      orgId,
      userId,
      sourceHash,
      start,
      end,
    }),
    createdAt: start,
  };
}

function buildSuggestionCandidate({
  rank,
  start,
  end,
  availableUserIds,
  missingUserIds,
}: {
  rank: number;
  start: Date;
  end: Date;
  availableUserIds: string[];
  missingUserIds: string[];
}) {
  return {
    rank,
    startAt: start,
    endAt: end,
    attendanceRatio: availableUserIds.length / (availableUserIds.length + missingUserIds.length),
    scoreTotal: 92 - rank,
    scoreAttendance: 100 - rank * 2,
    scoreInconvenience: 75 - rank,
    scoreFairness: 60 - rank,
    availableUserIds,
    missingUserIds,
    explanation: {
      note: "Seeded demo candidate",
    },
  };
}

async function main() {
  const org = await prisma.org.upsert({
    where: { slug: DEMO_ORG_SLUG },
    update: { name: DEMO_ORG_NAME },
    create: { name: DEMO_ORG_NAME, slug: DEMO_ORG_SLUG },
  });

  await Promise.all([
    prisma.membership.deleteMany({ where: { orgId: org.id } }),
    prisma.availabilityTemplate.deleteMany({ where: { orgId: org.id } }),
    prisma.availabilityOverride.deleteMany({ where: { orgId: org.id } }),
    prisma.busyBlock.deleteMany({ where: { orgId: org.id } }),
    prisma.suggestionRequest.deleteMany({ where: { orgId: org.id } }),
  ]);

  const createdUsers = {} as Record<
    DemoUser["key"],
    Awaited<ReturnType<typeof prisma.user.upsert>>
  >;

  for (const user of DEMO_USERS) {
    const created = await prisma.user.upsert({
      where: { email: user.email },
      create: { email: user.email, name: user.name },
      update: { name: user.name },
    });
    createdUsers[user.key] = created;
  }

  for (const user of DEMO_USERS) {
    await prisma.membership.create({
      data: {
        orgId: org.id,
        userId: createdUsers[user.key]!.id,
        role: user.role,
      },
    });

    const windows = AVAILABILITY_WINDOWS[user.key].map((window) => ({
      dayOfWeek: window.dayOfWeek,
      startMinute: window.startMinute,
      endMinute: window.endMinute,
    }));

    await prisma.availabilityTemplate.create({
      data: {
        orgId: org.id,
        userId: createdUsers[user.key]!.id,
        timeZone: user.timeZone,
        windows: {
          create: windows,
        },
      },
    });
  }

  const overrideStart = addMinutes(addDays(getMondayOfCurrentWeek(), 2), 11 * 60);
  const overrideEnd = addMinutes(overrideStart, 90);
  await prisma.availabilityOverride.create({
    data: {
      orgId: org.id,
      userId: createdUsers.leader!.id,
      kind: AvailabilityOverrideKind.UNAVAILABLE,
      note: "Demo retro-planning block",
      startAt: overrideStart,
      endAt: overrideEnd,
    },
  });

  for (const user of DEMO_USERS) {
    const patterns = BUSY_PATTERNS[user.key];
    for (const [index, pattern] of patterns.entries()) {
      await prisma.busyBlock.create({
        data: buildBusyBlockArgs({
          orgId: org.id,
          userId: createdUsers[user.key]!.id,
          pattern,
          patternIndex: index,
        }),
      });
    }
  }

  const monday = getMondayOfCurrentWeek();
  const requestStart = addDays(monday, 1);
  const requestEnd = addDays(requestStart, 4);
  const requestKey = "demo-weekly-request";

  const candidateBaseTimes = [
    {
      dayOffset: 0,
      startMinute: 13 * 60,
      durationMinutes: 60,
      attendees: [createdUsers.leader!.id, createdUsers.memberA!.id],
      missing: [createdUsers.memberB!.id],
    },
    {
      dayOffset: 1,
      startMinute: 10 * 60 + 30,
      durationMinutes: 60,
      attendees: [createdUsers.leader!.id, createdUsers.memberB!.id],
      missing: [createdUsers.memberA!.id],
    },
    {
      dayOffset: 3,
      startMinute: 15 * 60,
      durationMinutes: 90,
      attendees: [
        createdUsers.leader!.id,
        createdUsers.memberA!.id,
        createdUsers.memberB!.id,
      ],
      missing: [],
    },
  ];

  const candidates = candidateBaseTimes.map((candidate, index) =>
    buildSuggestionCandidate({
      rank: index + 1,
      start: addMinutes(addDays(requestStart, candidate.dayOffset), candidate.startMinute),
      end: addMinutes(
        addMinutes(addDays(requestStart, candidate.dayOffset), candidate.startMinute),
        candidate.durationMinutes,
      ),
      availableUserIds: candidate.attendees,
      missingUserIds: candidate.missing,
    }),
  );

  await prisma.suggestionRequest.create({
    data: {
      orgId: org.id,
      createdById: createdUsers.leader!.id,
      requestKey,
      title: "Demo weekly sync",
      timeZone: "America/Los_Angeles",
      rangeStart: requestStart,
      rangeEnd: requestEnd,
      durationMinutes: 60,
      stepMinutes: 15,
      dayStartMinute: 8 * 60,
      dayEndMinute: 20 * 60,
      dataFingerprint: createHash("sha256")
        .update(`${org.id}:${requestKey}`)
        .digest("hex"),
      attendees: {
        createMany: {
          data: DEMO_USERS.map((user) => ({ userId: createdUsers[user.key]!.id })),
        },
      },
      candidates: {
        createMany: {
          data: candidates,
        },
      },
    },
  });

  console.info("Demo data seeded.");
}

main()
  .catch((error) => {
    console.error("Failed to seed demo data:", error);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
</file>

<file path="packages/db/eslint.config.cjs">
const parser = require("@typescript-eslint/parser");

module.exports = [
  {
    ignores: ["dist", "node_modules"],
  },
  {
    files: ["**/*.ts"],
    languageOptions: {
      parser,
      parserOptions: {
        project: "./tsconfig.json",
        tsconfigRootDir: __dirname,
      },
    },
    rules: {},
  },
];
</file>

<file path="packages/shared/src/audit/log.ts">
import { prisma } from "@lattice/db";

export const AuditActions = {
  ORG_CREATED: "ORG_CREATED",
  MEMBER_INVITED: "MEMBER_INVITED",
  MEMBER_ROLE_UPDATED: "MEMBER_ROLE_UPDATED",
  MEMBER_REMOVED: "MEMBER_REMOVED",
  AVAILABILITY_TEMPLATE_UPDATED: "AVAILABILITY_TEMPLATE_UPDATED",
  AVAILABILITY_OVERRIDE_CREATED: "AVAILABILITY_OVERRIDE_CREATED",
  AVAILABILITY_OVERRIDE_DELETED: "AVAILABILITY_OVERRIDE_DELETED",
  CALENDAR_CONNECTED: "CALENDAR_CONNECTED",
  CALENDAR_DISCONNECTED: "CALENDAR_DISCONNECTED",
  CALENDAR_SYNC_STARTED: "CALENDAR_SYNC_STARTED",
  CALENDAR_SYNC_SUCCESS: "CALENDAR_SYNC_SUCCESS",
  CALENDAR_SYNC_FAILURE: "CALENDAR_SYNC_FAILURE",
  SUGGESTION_REQUEST_CREATED: "SUGGESTION_REQUEST_CREATED",
  SLOT_CONFIRMED: "SLOT_CONFIRMED",
  WRITEBACK_ATTEMPTED: "WRITEBACK_ATTEMPTED",
  ACCEPTANCE_CHECK: "ACCEPTANCE_CHECK",
} as const;

export type AuditAction = (typeof AuditActions)[keyof typeof AuditActions];

export type LogAuditOptions = {
  orgId: string;
  actorUserId?: string | null;
  action: AuditAction;
  targetType?: string;
  targetId?: string;
  metadata?: Record<string, unknown>;
};

export async function logAudit(options: LogAuditOptions) {
  try {
    await prisma.auditLog.create({
      data: {
        orgId: options.orgId,
        actorUserId: options.actorUserId ?? undefined,
        action: options.action,
        targetType: options.targetType ?? undefined,
        targetId: options.targetId ?? undefined,
        metadata: options.metadata ?? undefined,
      },
    });
  } catch (error) {
    console.warn("[audit] failed to record event", error);
  }
}
</file>

<file path="packages/shared/src/http/envelope.ts">
import type { ErrorCode } from "./error-codes";

type ResponseMeta = Record<string, unknown>;

export function ok<T>(data: T, meta?: ResponseMeta) {
  return meta === undefined ? { data } : { data, meta };
}

export function fail(code: ErrorCode, message: string, details?: unknown) {
  if (details === undefined) {
    return { error: { code, message } };
  }

  return { error: { code, message, details } };
}
</file>

<file path="packages/shared/src/http/error-codes.ts">
export const ErrorCodes = {
  UNAUTHENTICATED: "UNAUTHENTICATED",
  FORBIDDEN: "FORBIDDEN",
  NOT_FOUND: "NOT_FOUND",
  VALIDATION_ERROR: "VALIDATION_ERROR",
  RATE_LIMITED: "RATE_LIMITED",
  PROVIDER_ERROR: "PROVIDER_ERROR",
  FEATURE_DISABLED: "FEATURE_DISABLED",
  USER_NOT_FOUND: "USER_NOT_FOUND",
  NO_CONNECTION: "NO_CONNECTION",
  NOT_CONNECTED: "NOT_CONNECTED",
  NO_CALENDARS_SELECTED: "NO_CALENDARS_SELECTED",
  SYNC_FAILED: "SYNC_FAILED",
  BAD_CANDIDATE_RANK: "BAD_CANDIDATE_RANK",
  MUST_HAVE_OWNER: "MUST_HAVE_OWNER",
  INVALID_DATE_RANGE: "INVALID_DATE_RANGE",
  CONFLICT: "CONFLICT",
  IDEMPOTENCY_CONFLICT: "IDEMPOTENCY_CONFLICT",
  BAD_REQUEST: "BAD_REQUEST",
  ACCESS_TOO_LOW: "ACCESS_TOO_LOW",
} as const;

export type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];
</file>

<file path="packages/shared/eslint.config.cjs">
const parser = require("@typescript-eslint/parser");

module.exports = [
  {
    ignores: ["dist", "node_modules"],
  },
  {
    files: ["**/*.ts"],
    languageOptions: {
      parser,
      parserOptions: {
        project: "./tsconfig.json",
        tsconfigRootDir: __dirname,
      },
    },
    rules: {},
  },
];
</file>

<file path="types/lattice-db.d.ts">
declare module "@lattice/db" {
  import { PrismaClient } from "@prisma/client";

  export const prisma: PrismaClient;
}
</file>

<file path=".gitignore">
.env
.env.*
!.env.example

node_modules
.next
.DS_Store

dist
coverage
playwright-report
</file>

<file path=".nvmrc">
20
</file>

<file path=".prettierignore">
.next
dist
node_modules
pnpm-lock.yaml
</file>

<file path=".prettierrc.json">
{
  "semi": true,
  "singleQuote": false,
  "trailingComma": "all",
  "plugins": ["prettier-plugin-tailwindcss"]
}
</file>

<file path=".tool-versions">
nodejs 20.0.0
</file>

<file path="CODE_OF_CONDUCT.md">
# Contributor Covenant Code of Conduct

## Our Pledge
We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual
identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards
Examples of behavior that contributes to a positive environment for our
community include:

- Demonstrating empathy and kindness toward other people
- Being respectful of differing opinions, viewpoints, and experiences
- Giving and gracefully accepting constructive feedback
- Accepting responsibility and apologizing to those affected by our mistakes,
and learning from the experience
- Focusing on what is best not just for us as individuals, but for the overall
community

Examples of unacceptable behavior include:

- The use of sexualized language or imagery, and sexual attention or advances of
any kind
- Trolling, insulting or derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others’ private information, such as a physical or email address,
without their explicit permission
- Other conduct which could reasonably be considered inappropriate in a
professional setting

## Enforcement Responsibilities
Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope
This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.

## Enforcement
Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
security@lattice.dev. All complaints will be reviewed and investigated
promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Attribution
This Code of Conduct is adapted from the Contributor Covenant, version 2.1,
available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.
</file>

<file path="docker-compose.yml">
services:
  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: lattice
      POSTGRES_PASSWORD: lattice
      POSTGRES_DB: lattice
    ports:
      - "5432:5432"
    volumes:
      - pg_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  pg_data:
  redis_data:
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Wholesway

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="pnpm-workspace.yaml">
packages:
  - "apps/*"
  - "packages/*"
</file>

<file path="tsconfig.base.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "skipLibCheck": true,
    "noUncheckedIndexedAccess": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true
  }
}
</file>

<file path="apps/web/src/app/(app)/dashboard/page.tsx">
import { prisma } from "@lattice/db";
import { logAudit, AuditActions } from "@lattice/shared";
import { auth } from "@/auth";
import Link from "next/link";
import { redirect } from "next/navigation";
import { revalidatePath } from "next/cache";
import { setActiveOrgId, getActiveOrgId } from "@/lib/org-context";
import { env } from "@/lib/env";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

export default async function Dashboard() {
  const session = await auth();
  const userId = session?.user?.id;
  if (!userId) redirect("/signin");

  const orgs = await prisma.org.findMany({
    where: { members: { some: { userId } } },
    orderBy: { createdAt: "asc" },
    select: { id: true, name: true, slug: true },
  });

  async function createOrg(formData: FormData) {
    "use server";
    const session = await auth();
    const userId = session?.user?.id;
    if (!userId) redirect("/signin");

    const name = String(formData.get("name") ?? "").trim();
    if (name.length < 2) return;

    const org = await prisma.org.create({
      data: {
        name,
        slug: name.toLowerCase().replace(/\W+/g, "-").replace(/(^-|-$)/g, ""),
        members: { create: { userId, role: "OWNER" } },
      },
      select: { id: true, slug: true },
    });

    await logAudit({
      orgId: org.id,
      actorUserId: userId,
      action: AuditActions.ORG_CREATED,
      targetType: "Org",
      targetId: org.id,
      metadata: { name, slug: org.slug },
    });

    await setActiveOrgId(org.id);
    revalidatePath("/dashboard");
  }

  async function switchOrg(formData: FormData) {
    "use server";
    const orgId = String(formData.get("orgId") ?? "");
    if (!orgId) return;

    const session = await auth();
    const userId = session?.user?.id;
    if (!userId) redirect("/signin");

    const membership = await prisma.membership.findUnique({
      where: { orgId_userId: { orgId, userId } },
      select: { id: true },
    });

    if (!membership) return;

    await setActiveOrgId(orgId);
    revalidatePath("/dashboard");
  }

  const activeOrgId = await getActiveOrgId();

  return (
    <main className="space-y-8 px-6 py-8">
      <section className="space-y-4 rounded-2xl border border-border bg-background/70 p-6 shadow-sm">
        <div className="flex flex-col gap-1">
          <h1 className="text-3xl font-semibold">Dashboard</h1>
          <p className="text-sm text-muted-foreground">
            Switch organizations, create new ones, and navigate to the features you
            use most.
          </p>
        </div>

        <div className="flex flex-col gap-4">
          <form action={switchOrg} className="flex flex-col gap-3 sm:flex-row sm:items-center">
            <Select
              name="orgId"
              defaultValue={activeOrgId ?? ""}
              className="w-full sm:w-[240px]"
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Select an org…" />
              </SelectTrigger>
              <SelectContent>
                {orgs.map((org) => (
                  <SelectItem key={org.id} value={org.id}>
                    {org.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>

            <Button type="submit" variant="secondary">
              Switch org
            </Button>
          </form>

          <p className="text-sm text-muted-foreground">
            Active org: <span className="font-semibold">{activeOrgId ?? "(none)"}</span>
          </p>
        </div>

        <Link
          href="/availability"
          className="text-sm font-medium text-primary hover:underline"
        >
          Go to availability management
        </Link>
      </section>

      <section className="rounded-2xl border border-border bg-background/60 p-6">
        <div className="flex flex-col gap-1">
          <h2 className="text-xl font-semibold">Create an org</h2>
          <p className="text-sm text-muted-foreground">
            Give it a descriptive name so the slug stays readable.
          </p>
        </div>
        <form action={createOrg} className="mt-4 flex flex-col gap-3 sm:flex-row">
          <Input
            name="name"
            placeholder="e.g. Delaware DSA"
            required
            className="w-full"
          />
          <Button type="submit">Create</Button>
        </form>
      </section>

      <section className="space-y-4 rounded-2xl border border-border bg-background/60 p-6">
        <div className="flex items-center justify-between">
          <h2 className="text-xl font-semibold">Your orgs</h2>
          <span className="text-xs uppercase tracking-wide text-muted-foreground">
            {orgs.length} total
          </span>
        </div>
        <div className="space-y-3">
          {orgs.map((org) => (
            <div
              key={org.id}
              className="flex flex-wrap items-baseline gap-2 rounded-xl border border-border/60 bg-muted/5 px-4 py-3"
            >
              <span className="font-medium">{org.name}</span>
              <span className="text-sm text-muted-foreground">/{org.slug}</span>
            </div>
          ))}
        </div>
        <div className="flex flex-wrap gap-3 text-sm">
          {env.SUGGESTIONS_ENABLED && (
            <Link
              href="/suggestions"
              className="text-primary hover:underline"
            >
              Suggestions (Phase 3)
            </Link>
          )}
          {env.EVENTS_ENABLED && (
            <Link
              href="/events"
              className="text-primary hover:underline"
            >
              Events (Phase 5)
            </Link>
          )}
        </div>
      </section>

      <section className="rounded-2xl border border-border bg-background/60 p-6">
        <h2 className="text-xl font-semibold">Audit log</h2>
        <p className="text-sm text-muted-foreground">
          Admins can inspect the most recent audit events for the active organization.
        </p>
        <Link href="/audit" className="mt-3 inline-flex text-sm font-medium text-primary hover:underline">
          View audit log
        </Link>
      </section>
    </main>
  );
}
</file>

<file path="apps/web/src/app/(app)/integrations/google-calendar-panel.tsx">
"use client"

import Link from "next/link"
import { useCallback, useEffect, useMemo, useState } from "react"
import { toast } from "sonner"

import { ApiError, fetchJson } from "@/lib/http"

import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"

type CalendarRow = {
  idHash: string
  summary: string
  primary: boolean
  accessRole: string
  isBusySource: boolean
}

export function GoogleCalendarPanel({ orgId }: { orgId: string }) {
  const [loading, setLoading] = useState(true)
  const [rows, setRows] = useState<CalendarRow[]>([])
  const [saving, setSaving] = useState(false)
  const [syncing, setSyncing] = useState(false)
  const [disconnecting, setDisconnecting] = useState(false)

  const selected = useMemo(
    () => new Set(rows.filter((r) => r.isBusySource).map((r) => r.idHash)),
    [rows],
  )

  const load = useCallback(async () => {
    setLoading(true)
    try {
      const data = await fetchJson<{ calendars?: CalendarRow[] }>(
        `/api/orgs/${orgId}/integrations/google/calendars`,
        { cache: "no-store" },
      )
      setRows(data.calendars ?? [])
    } catch (err) {
      const message = err instanceof ApiError ? err.message : "Failed to load calendars."
      toast.error(message)
    } finally {
      setLoading(false)
    }
  }, [orgId])

  useEffect(() => {
    void load()
  }, [load])

  function toggle(idHash: string) {
    setRows((prev) =>
      prev.map((row) =>
        row.idHash === idHash ? { ...row, isBusySource: !row.isBusySource } : row,
      ),
    )
  }

  async function save() {
    setSaving(true)
    try {
      await fetchJson(`/api/orgs/${orgId}/integrations/google/selections`, {
        method: "PUT",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ busyCalendarIdHashes: [...selected] }),
      })
      toast.success("Selections saved")
    } catch (err) {
      const message = err instanceof ApiError ? err.message : "Save failed."
      toast.error(message)
    } finally {
      setSaving(false)
    }
  }

  async function sync() {
    setSyncing(true)
    try {
      const data = await fetchJson<{ blocks?: number }>(
        `/api/orgs/${orgId}/integrations/google/sync`,
        {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({}),
        },
      )
      toast.success(`Synced. Busy blocks stored: ${data.blocks ?? 0}`)
    } catch (err) {
      const message = err instanceof ApiError ? err.message : "Sync failed."
      toast.error(message)
    } finally {
      setSyncing(false)
    }
  }

  async function disconnect() {
    setDisconnecting(true)
    try {
      await fetchJson(`/api/orgs/${orgId}/integrations/google/calendars`, {
        method: "DELETE",
      })
      toast.success("Disconnected. Reloading…")
      window.location.reload()
    } catch (err) {
      const message = err instanceof ApiError ? err.message : "Disconnect failed."
      toast.error(message)
    } finally {
      setDisconnecting(false)
    }
  }

  if (loading) {
    return <p className="text-sm text-muted-foreground">Loading calendars…</p>
  }

  return (
    <div className="space-y-4">
      <div className="space-y-3">
        {rows.map((row) => (
          <label
            key={row.idHash}
            className="flex flex-wrap items-start gap-3 text-sm"
          >
            <Checkbox
              checked={row.isBusySource}
              onCheckedChange={() => toggle(row.idHash)}
            />
            <div className="flex flex-col gap-1">
              <span className="font-medium">
                {row.summary}
                {row.primary ? " (Primary)" : ""}
              </span>
              <span className="text-xs text-muted-foreground">{row.accessRole}</span>
            </div>
          </label>
        ))}
      </div>

      <div className="flex flex-wrap gap-3">
        <Button onClick={save} disabled={saving} size="sm">
          {saving ? "Saving…" : "Save selections"}
        </Button>
        <Button variant="outline" onClick={sync} disabled={syncing} size="sm">
          {syncing ? "Syncing…" : "Sync now"}
        </Button>
        <Dialog>
          <DialogTrigger asChild>
            <Button variant="ghost" disabled={disconnecting} size="sm">
              Disconnect
            </Button>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Disconnect Google Calendar</DialogTitle>
              <DialogDescription>
                This will disconnect all synced calendars and stop future updates.
              </DialogDescription>
            </DialogHeader>
            <DialogFooter className="flex justify-end gap-2">
              <DialogClose asChild>
                <Button variant="outline" size="sm">
                  Cancel
                </Button>
              </DialogClose>
              <DialogClose asChild>
                <Button
                  variant="destructive"
                  size="sm"
                  onClick={disconnect}
                  disabled={disconnecting}
                >
                  {disconnecting ? "Disconnecting…" : "Disconnect"}
                </Button>
              </DialogClose>
            </DialogFooter>
          </DialogContent>
        </Dialog>
        <Link
          href={`/api/orgs/${orgId}/integrations/google/start`}
          className="text-sm text-primary hover:underline"
        >
          Reconnect
        </Link>
      </div>
    </div>
  )
}
</file>

<file path="apps/web/src/app/(app)/suggestions/page.tsx">
import { redirect } from "next/navigation"

import { auth } from "@/auth"
import { prisma } from "@lattice/db"
import { getActiveOrgId } from "@/lib/org-context"
import { roleAtLeast } from "@/lib/rbac"
import { env } from "@/lib/env"
import SuggestionsClient from "@/features/suggestions/SuggestionsClient"

export default async function SuggestionsPage() {
  if (!env.SUGGESTIONS_ENABLED) {
    redirect("/dashboard")
  }

  const session = await auth()
  const userId = session?.user?.id ?? redirect("/signin")

  const orgId = await getActiveOrgId()
  if (!orgId) {
    redirect("/dashboard")
  }

  const membership = await prisma.membership.findUnique({
    where: { orgId_userId: { orgId, userId } },
    select: { role: true },
  })

  if (!membership || !roleAtLeast(membership.role, "LEADER")) {
    redirect("/dashboard")
  }

  const org = await prisma.org.findUnique({
    where: { id: orgId },
    select: { id: true, name: true },
  })

  if (!org) {
    redirect("/dashboard")
  }

  return (
    <div style={{ padding: 24 }}>
      <h1>Suggestions</h1>
      <p>Create a request and get ranked meeting slots based on member availability.</p>
      <SuggestionsClient orgId={org.id} orgName={org.name} />
    </div>
  )
}
</file>

<file path="apps/web/src/app/(app)/layout.tsx">
import * as React from "react";
import { auth, signOut } from "@/auth";
import { prisma } from "@lattice/db";
import Link from "next/link";
import { env } from "@/lib/env";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";

export default async function AppLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await auth();
  const calendarConnection =
    session?.user?.id &&
    (await prisma.calendarConnection.findFirst({
      where: {
        userId: session.user.id,
        provider: "GOOGLE",
        status: "ACTIVE",
      },
      select: { id: true },
    }));
  const showDemoBanner = Boolean(session?.user?.id && !calendarConnection);

  const navLinks = [
    { label: "Dashboard", href: "/dashboard" },
    { label: "Availability", href: "/availability" },
    env.SUGGESTIONS_ENABLED ? { label: "Suggestions", href: "/suggestions" } : null,
    { label: "Audit log", href: "/audit" },
    env.EVENTS_ENABLED ? { label: "Events", href: "/events" } : null,
  ].filter((link): link is { label: string; href: string } => Boolean(link));

  return (
    <div className="min-h-screen bg-background text-foreground">
      <header className="flex flex-wrap items-center justify-between gap-4 border-b border-border px-6 py-4">
        <div className="flex items-center gap-2">
          <Link
            href="/dashboard"
            className="text-lg font-semibold tracking-tight focus-visible:ring-ring focus-visible:ring-2"
          >
            Lattice
          </Link>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm">
                Navigate
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="start">
              {navLinks.map((link, index) => (
                <React.Fragment key={`${link.href}-${index}`}>
                  <DropdownMenuItem asChild>
                    <Link href={link.href}>{link.label}</Link>
                  </DropdownMenuItem>
                  {index === 1 && <DropdownMenuSeparator />}
                </React.Fragment>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>

        <div className="flex items-center gap-3">
          <span className="text-sm text-muted-foreground">{session?.user?.email ?? ""}</span>
          <form
            action={async () => {
              "use server";
              await signOut({ redirectTo: "/" });
            }}
          >
            <Button variant="outline" size="sm" type="submit">
              Sign out
            </Button>
          </form>
        </div>
      </header>

      {showDemoBanner && (
        <div className="border-b border-border bg-muted/40 px-4 py-2 text-center text-sm text-muted-foreground">
          Demo mode: using simulated busy blocks
        </div>
      )}

      {children}
    </div>
  );
}
</file>

<file path="apps/web/src/app/api/auth/[...nextauth]/route.ts">
import { NextResponse } from "next/server";

import {
  buildRateLimitKey,
  buildRetryAfterHeader,
  enforceRateLimit,
  getRequestIp,
} from "@lattice/shared";
import { GET as nextAuthGET, POST as nextAuthPOST } from "@/auth";

/**
 * @openapi
 * /api/auth/{nextAuthPath}:
 *   summary: NextAuth endpoints for authentication flows.
 *   parameters:
 *     - name: nextAuthPath
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *         description: Catch-all path used by NextAuth for session, sign-in, callbacks, and providers.
 *   get:
 *     summary: Serves provider metadata, session status, and callback redirects.
 *     responses:
 *       "200":
 *         description: NextAuth processed the GET request.
 *   post:
 *     summary: Accepts sign-in, callback, and credential payloads from clients.
 *     requestBody:
 *       required: true
 *       content:
 *         application/x-www-form-urlencoded:
 *           schema:
 *             type: object
 *             description: Form encoded payload handled by NextAuth.
 *     responses:
 *       "200":
 *         description: NextAuth processed the POST request.
 */

const RATE_LIMIT_SCOPE = "auth";

async function applyAuthRateLimit(req: Request) {
  const key = buildRateLimitKey(RATE_LIMIT_SCOPE, [getRequestIp(req)]);
  const result = await enforceRateLimit(RATE_LIMIT_SCOPE, key);
  if (result.allowed) {
    return null;
  }

  return NextResponse.json(result.response, {
    status: 429,
    headers: buildRetryAfterHeader(result.retryAfterSeconds),
  });
}

export async function GET(req: Request) {
  const rateLimitResponse = await applyAuthRateLimit(req);
  if (rateLimitResponse) return rateLimitResponse;
  return nextAuthGET(req);
}

export async function POST(req: Request) {
  const rateLimitResponse = await applyAuthRateLimit(req);
  if (rateLimitResponse) return rateLimitResponse;
  return nextAuthPOST(req);
}

export const runtime = "nodejs";
</file>

<file path="apps/web/src/app/api/db-ping/route.ts">
import { prisma } from "@lattice/db";
import { env } from "@/lib/env";
import { ok } from "@lattice/shared";

/**
 * @openapi
 * /api/db-ping:
 *   get:
 *     summary: Runs a simple SQL query to verify database readiness.
 *     tags:
 *       - Health
 *     responses:
 *       "200":
 *         description: Database responded with the current time.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     now:
 *                       type: string
 *                       format: date-time
 *                     environment:
 *                       type: string
 */
export async function GET() {
  const result = (await prisma.$queryRawUnsafe(
    "select now() as now"
  )) as { now: string }[];
  return Response.json(
    ok({
      now: result?.[0]?.now ?? null,
      environment: env.NODE_ENV,
    })
  );
}
</file>

<file path="apps/web/src/app/api/health/route.ts">
import { ok } from "@lattice/shared";

/**
 * @openapi
 * /api/health:
 *   get:
 *     summary: Returns a lightweight success response when the app is healthy.
 *     tags:
 *       - Health
 *     responses:
 *       "200":
 *         description: Health check succeeded.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   description: Empty envelope used for health checks.
 */
export async function GET() {
  return Response.json(ok({}));
}
</file>

<file path="apps/web/src/app/api/integrations/google/callback/route.ts">
import { NextResponse } from "next/server";

import { auth } from "@/auth";
import { prisma } from "@lattice/db";
import { logAudit, AuditActions } from "@lattice/shared";
import { env } from "@/lib/env";
import { readOauthCookie, clearOauthCookie } from "@/lib/google/oauth";
import { encryptString } from "@/lib/crypto/secretbox";
import { getGcalScopes } from "@/lib/google/calendar";

export const runtime = "nodejs";

/**
 * @openapi
 * /api/integrations/google/callback:
 *   get:
 *     summary: Handles the Google OAuth callback and persists calendar credentials.
 *     tags:
 *       - Integrations
 *     parameters:
 *       - name: code
 *         in: query
 *         schema:
 *           type: string
 *       - name: state
 *         in: query
 *         schema:
 *           type: string
 *       - name: error
 *         in: query
 *         schema:
 *           type: string
 *     responses:
 *       "302":
 *         description: Redirects back to the integrations page with a result flag.
 */
async function exchangeToken(args: { code: string; codeVerifier: string }) {
  const res = await fetch("https://oauth2.googleapis.com/token", {
    method: "POST",
    headers: { "content-type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams({
      code: args.code,
      client_id: env.GCAL_CLIENT_ID,
      client_secret: env.GCAL_CLIENT_SECRET,
      redirect_uri: env.GCAL_REDIRECT_URI,
      grant_type: "authorization_code",
      code_verifier: args.codeVerifier,
    }),
  });
  const json = await res.json();
  if (!res.ok) throw new Error(`token_exchange_failed: ${JSON.stringify(json)}`);
  return json as { refresh_token?: string; scope?: string };
}

export async function GET(req: Request) {
  const session = await auth();
  const url = new URL(req.url);
  const code = url.searchParams.get("code");
  const state = url.searchParams.get("state");
  const error = url.searchParams.get("error");

  const cookie = await readOauthCookie();
  await clearOauthCookie();

  if (error || !code || !state || !cookie) return NextResponse.redirect(new URL("/integrations?gcal=error", url.origin));

  const expectedState = cookie["state"];
  const verifier = cookie["verifier"];
  const userId = cookie["userId"];

  if (
    typeof expectedState !== "string" ||
    typeof verifier !== "string" ||
    typeof userId !== "string" ||
    state !== expectedState ||
    !session?.user?.id ||
    session.user.id !== userId
  ) {
    return NextResponse.redirect(new URL("/integrations?gcal=error", url.origin));
  }

  const token = await exchangeToken({ code, codeVerifier: verifier });
  if (!token.refresh_token) return NextResponse.redirect(new URL("/integrations?gcal=no_refresh_token", url.origin));

  const defaultScopes = getGcalScopes().join(" ");
  const scopes = token.scope ?? defaultScopes;

  const connection = await prisma.calendarConnection.upsert({
    where: { userId_provider: { userId, provider: "GOOGLE" } },
    update: {
      scopes,
      encryptedRefreshToken: encryptString(token.refresh_token),
      status: "ACTIVE",
    },
    create: {
      userId,
      provider: "GOOGLE",
      scopes,
      encryptedRefreshToken: encryptString(token.refresh_token),
      status: "ACTIVE",
    },
    select: { id: true },
  });

  const orgIdFromCookie = typeof cookie["orgId"] === "string" ? cookie["orgId"] : null;
  if (orgIdFromCookie) {
    await logAudit({
      orgId: orgIdFromCookie,
      actorUserId: userId,
      action: AuditActions.CALENDAR_CONNECTED,
      targetType: "CalendarConnection",
      targetId: connection.id,
      metadata: { provider: "GOOGLE", scopes },
    });
  }

  return NextResponse.redirect(new URL("/integrations?gcal=connected", url.origin));
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/availability/[userId]/route.ts">
import { NextRequest, NextResponse } from "next/server"

import { prisma } from "@lattice/db"
import { fail, ok, ErrorCodes } from "@lattice/shared"
import { requireOrgAccess } from "@/lib/guards"

export const runtime = "nodejs"

/**
 * @openapi
 * /api/orgs/{orgId}/availability/{userId}:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *     - name: userId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   get:
 *     summary: Retrieves availability template and overrides for a specific attendee.
 *     tags:
 *       - Availability
 *     responses:
 *       "200":
 *         description: Availability data for the requested attendee.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     timeZone:
 *                       type: string
 *                     windows:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           dayOfWeek:
 *                             type: integer
 *                           startMinute:
 *                             type: integer
 *                           endMinute:
 *                             type: integer
 *                     overrides:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           id:
 *                             type: string
 *                           startAt:
 *                             type: string
 *                             format: date-time
 *                           endAt:
 *                             type: string
 *                             format: date-time
 *                           kind:
 *                             type: string
 *                           note:
 *                             type: string
 *       "401":
 *         description: Unauthorized access.
 */
export async function GET(
  _req: NextRequest,
  { params }: { params: { orgId: string; userId: string } }
) {
  const { orgId, userId } = params

  try {
    const access = await requireOrgAccess(orgId, { minRole: "LEADER", notFoundOnFail: true })
    if (!access.ok) return access.response

    const template = await prisma.availabilityTemplate.findUnique({
      where: { orgId_userId: { orgId, userId } },
      include: { windows: true },
    })

    const overrides = await prisma.availabilityOverride.findMany({
      where: { orgId, userId },
      orderBy: { startAt: "asc" },
    })

    return NextResponse.json(
      ok({
        timeZone: template?.timeZone ?? "UTC",
        windows:
          template?.windows
            .map((w) => ({
              dayOfWeek: w.dayOfWeek,
              startMinute: w.startMinute,
              endMinute: w.endMinute,
            }))
            .sort((a, b) => a.dayOfWeek - b.dayOfWeek || a.startMinute - b.startMinute) ?? [],
        overrides: overrides.map((o) => ({
          id: o.id,
          startAt: o.startAt.toISOString(),
          endAt: o.endAt.toISOString(),
          kind: o.kind,
          note: o.note,
        })),
      })
    )
  } catch {
    return NextResponse.json(
      fail(ErrorCodes.UNAUTHENTICATED, "unauthorized"),
      { status: 401 }
    )
  }
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/availability/me/overrides/[overrideId]/route.ts">
import { NextRequest, NextResponse } from "next/server"

import { prisma } from "@lattice/db"
import { fail, ok, ErrorCodes, logAudit, AuditActions } from "@lattice/shared"
import { requireOrgAccess } from "@/lib/guards"

export const runtime = "nodejs"

function respondUnauthorized() {
  return NextResponse.json(
    fail(ErrorCodes.UNAUTHENTICATED, "unauthorized"),
    { status: 401 }
  )
}

/**
 * @openapi
 * /api/orgs/{orgId}/availability/me/overrides/{overrideId}:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *     - name: overrideId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   delete:
 *     summary: Deletes a personal availability override.
 *     tags:
 *       - Availability
 *     responses:
 *       "200":
 *         description: Override removed.
 *       "401":
 *         description: Authentication required.
 *       "404":
 *         description: Override not found.
 */
export async function DELETE(
  _req: NextRequest,
  { params }: { params: { orgId: string; overrideId: string } }
) {
  const { orgId, overrideId } = params

  try {
    const access = await requireOrgAccess(orgId)
    if (!access.ok) return access.response

    const userId = access.membership.userId

    const existing = await prisma.availabilityOverride.findUnique({
      where: { id: overrideId },
      select: {
        orgId: true,
        userId: true,
        startAt: true,
        endAt: true,
        kind: true,
        note: true,
      },
    })
    if (!existing || existing.orgId !== orgId || existing.userId !== userId) {
      return NextResponse.json(
        fail(ErrorCodes.NOT_FOUND, "not_found"),
        { status: 404 }
      )
    }

    await prisma.availabilityOverride.delete({ where: { id: overrideId } })

    await logAudit({
      orgId,
      actorUserId: userId,
      action: AuditActions.AVAILABILITY_OVERRIDE_DELETED,
      targetType: "AvailabilityOverride",
      targetId: overrideId,
      metadata: {
        kind: existing.kind,
        startAt: existing.startAt.toISOString(),
        endAt: existing.endAt.toISOString(),
        note: existing.note,
      },
    });
    return NextResponse.json(ok({}))
  } catch {
    return respondUnauthorized()
  }
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/events/[eventId]/route.ts">
import { NextResponse } from "next/server";

import { prisma } from "@lattice/db";
import { env } from "@/lib/env";
import { fail, ok, ErrorCodes } from "@lattice/shared";
import { requireOrgAccess } from "@/lib/guards";

export const runtime = "nodejs";

/**
 * @openapi
 * /api/orgs/{orgId}/events/{eventId}:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *     - name: eventId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   get:
 *     summary: Fetches details for a single scheduled event.
 *     tags:
 *       - Events
 *     responses:
 *       "200":
 *         description: Event and attendee metadata returned.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     event:
 *                       type: object
 *                       properties:
 *                         id:
 *                           type: string
 *                         title:
 *                           type: string
 *                         startUtc:
 *                           type: string
 *                           format: date-time
 *                         endUtc:
 *                           type: string
 *                           format: date-time
 *                         attendees:
 *                           type: array
 *                           items:
 *                             type: object
 *                             properties:
 *                               user:
 *                                 type: object
 *                                 properties:
 *                                   id:
 *                                     type: string
 *       "401":
 *         description: Authentication required.
 *       "404":
 *         description: Event not found.
 */
export async function GET(
  _req: Request,
  ctx: { params: Promise<{ orgId: string; eventId: string }> }
) {
  const { orgId, eventId } = await ctx.params;

  if (!env.EVENTS_ENABLED) {
    return NextResponse.json(
      fail(ErrorCodes.FEATURE_DISABLED, "disabled"),
      { status: 404 }
    );
  }

  const access = await requireOrgAccess(orgId);
  if (!access.ok) return access.response;

  const event = await prisma.scheduledEvent.findFirst({
    where: { id: eventId, orgId },
    include: { attendees: { include: { user: { select: { id: true, name: true, email: true } } } } },
  });

  if (!event) {
    return NextResponse.json(
      fail(ErrorCodes.NOT_FOUND, "not_found"),
      { status: 404 }
    );
  }

  return NextResponse.json(ok({ event }));
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/events/route.ts">
import { NextResponse } from "next/server";

import { prisma } from "@lattice/db";
import { env } from "@/lib/env";
import { fail, ok, ErrorCodes } from "@lattice/shared";
import { requireOrgAccess } from "@/lib/guards";

export const runtime = "nodejs";

/**
 * @openapi
 * /api/orgs/{orgId}/events:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   get:
 *     summary: Lists upcoming scheduled events for an organization.
 *     tags:
 *       - Events
 *     responses:
 *       "200":
 *         description: Upcoming events sorted by start time.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     events:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           id:
 *                             type: string
 *                           title:
 *                             type: string
 *                           startUtc:
 *                             type: string
 *                             format: date-time
 *                           endUtc:
 *                             type: string
 *                             format: date-time
 *                           attendees:
 *                             type: array
 *                             items:
 *                               type: object
 *                               properties:
 *                                 user:
 *                                   type: object
 *                                   properties:
 *                                     id:
 *                                       type: string
 *                                     name:
 *                                       type: string
 *                                     email:
 *                                       type: string
 *       "401":
 *         description: Authentication required.
 */
export async function GET(_req: Request, ctx: { params: Promise<{ orgId: string }> }) {
  const { orgId } = await ctx.params;

  if (!env.EVENTS_ENABLED) {
    return NextResponse.json(
      fail(ErrorCodes.FEATURE_DISABLED, "disabled"),
      { status: 404 }
    );
  }

  const access = await requireOrgAccess(orgId);
  if (!access.ok) return access.response;

  const now = new Date();

  const events = await prisma.scheduledEvent.findMany({
    where: { orgId, endUtc: { gte: now } },
    orderBy: { startUtc: "asc" },
    take: 50,
    include: { attendees: { include: { user: { select: { id: true, name: true, email: true } } } } },
  });

  return NextResponse.json(ok({ events }));
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/members/[membershipId]/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";

import { prisma } from "@lattice/db";
import {
  fail,
  ok,
  ErrorCodes,
  logAudit,
  AuditActions,
  buildRateLimitKey,
  buildRetryAfterHeader,
  enforceRateLimit,
} from "@lattice/shared";
import { requireOrgAccess } from "@/lib/guards";

export const runtime = "nodejs";

const UpdateRoleSchema = z.object({
  role: z.enum(["OWNER", "ADMIN", "LEADER", "MEMBER"]),
});

/**
 * @openapi
 * /api/orgs/{orgId}/members/{membershipId}:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *     - name: membershipId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   patch:
 *     summary: Updates a member's role (owner-only changes).
 *     tags:
 *       - Members
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               role:
 *                 type: string
 *                 enum:
 *                   - OWNER
 *                   - ADMIN
 *                   - LEADER
 *                   - MEMBER
 *             required:
 *               - role
 *     responses:
 *       "200":
 *         description: Membership updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 membership:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: string
 *                     role:
 *                       type: string
 *       "400":
 *         description: Validation error or owner limit.
 *       "401":
 *         description: Authentication required.
 *       "403":
 *         description: Insufficient permissions.
 *   delete:
 *     summary: Removes a member from the organization.
 *     tags:
 *       - Members
 *     responses:
 *       "200":
 *         description: Membership deleted.
 *       "401":
 *         description: Authentication required.
 *       "403":
 *         description: Insufficient permissions.
 */
export async function PATCH(
  req: Request,
  ctx: { params: Promise<{ orgId: string; membershipId: string }> }
) {
  const { orgId, membershipId } = await ctx.params;

  const access = await requireOrgAccess(orgId, {
    minRole: "OWNER",
    notFoundOnFail: true,
  });
  if (!access.ok) return access.response;

  const membershipLimit = await enforceRateLimit(
    "membership",
    buildRateLimitKey("membership", [orgId, access.membership.userId])
  );
  if (!membershipLimit.allowed) {
    return NextResponse.json(
      membershipLimit.response,
      {
        status: 429,
        headers: buildRetryAfterHeader(membershipLimit.retryAfterSeconds),
      }
    );
  }

  const body = await req.json().catch(() => null);
  const parsed = UpdateRoleSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      fail(
        ErrorCodes.VALIDATION_ERROR,
        "invalid_input",
        parsed.error.flatten()
      ),
      { status: 400 }
    );
  }

  if (parsed.data.role !== "OWNER") {
    const target = await prisma.membership.findUnique({
      where: { id: membershipId },
      select: { role: true, userId: true },
    });

    if (target?.role === "OWNER") {
      const owners = await prisma.membership.count({
        where: { orgId, role: "OWNER" },
      });
      if (owners <= 1) {
        return NextResponse.json(
          fail(ErrorCodes.MUST_HAVE_OWNER, "must_have_owner"),
          { status: 400 }
        );
      }
    }
  }

  const updated = await prisma.membership.update({
    where: { id: membershipId },
    data: { role: parsed.data.role },
    select: { id: true, role: true },
  });

  await logAudit({
    orgId,
    actorUserId: access.membership.userId,
    action: AuditActions.MEMBER_ROLE_UPDATED,
    targetType: "Membership",
    targetId: updated.id,
    metadata: {
      userId: target?.userId,
      previousRole: target?.role,
      newRole: updated.role,
    },
  });

  return NextResponse.json({ membership: updated });
}

export async function DELETE(
  _req: Request,
  ctx: { params: Promise<{ orgId: string; membershipId: string }> }
) {
  const { orgId, membershipId } = await ctx.params;

  const access = await requireOrgAccess(orgId, {
    minRole: "ADMIN",
    notFoundOnFail: true,
  });
  if (!access.ok) return access.response;

  const membershipLimit = await enforceRateLimit(
    "membership",
    buildRateLimitKey("membership", [orgId, access.membership.userId])
  );
  if (!membershipLimit.allowed) {
    return NextResponse.json(
      membershipLimit.response,
      {
        status: 429,
        headers: buildRetryAfterHeader(membershipLimit.retryAfterSeconds),
      }
    );
  }

  const target = await prisma.membership.findUnique({
    where: { id: membershipId },
    select: { role: true, userId: true },
  });

  if (target?.role === "OWNER") {
    const owners = await prisma.membership.count({
      where: { orgId, role: "OWNER" },
    });
    if (owners <= 1) {
    return NextResponse.json(
      fail(ErrorCodes.MUST_HAVE_OWNER, "must_have_owner"),
      { status: 400 }
    );
    }
  }

  await prisma.membership.delete({ where: { id: membershipId } });

  await logAudit({
    orgId,
    actorUserId: access.membership.userId,
    action: AuditActions.MEMBER_REMOVED,
    targetType: "Membership",
    targetId: membershipId,
    metadata: {
      userId: target?.userId,
      role: target?.role,
    },
  });
  return NextResponse.json(ok({}));
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";

import { prisma } from "@lattice/db";
import { fail, ok, ErrorCodes } from "@lattice/shared";
import { requireOrgAccess } from "@/lib/guards";

export const runtime = "nodejs";

const UpdateOrgSchema = z.object({
  name: z.string().min(2).max(80),
});

/**
 * @openapi
 * /api/orgs/{orgId}:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   get:
 *     summary: Loads organization metadata for the authenticated user.
 *     tags:
 *       - Orgs
 *     responses:
 *       "200":
 *         description: Organization details returned.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     org:
 *                       type: object
 *                       properties:
 *                         id:
 *                           type: string
 *                         name:
 *                           type: string
 *                         slug:
 *                           type: string
 *                         createdAt:
 *                           type: string
 *                           format: date-time
 *       "401":
 *         description: Authentication required.
 *       "404":
 *         description: Organization not found.
 *   patch:
 *     summary: Updates an organization name (admin+).
 *     tags:
 *       - Orgs
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *             required:
 *               - name
 *     responses:
 *       "200":
 *         description: Organization updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     org:
 *                       type: object
 *                       properties:
 *                         id:
 *                           type: string
 *                         name:
 *                           type: string
 *                         slug:
 *                           type: string
 *       "400":
 *         description: Validation error.
 *       "401":
 *         description: Authentication required.
 *       "404":
 *         description: Not found.
 *   delete:
 *     summary: Deletes an organization (owner only).
 *     tags:
 *       - Orgs
 *     responses:
 *       "200":
 *         description: Organization removed.
 *       "401":
 *         description: Authentication required.
 *       "403":
 *         description: Insufficient permissions.
 *       "404":
 *         description: Organization not found.
 */
export async function GET(
  _req: Request,
  ctx: { params: Promise<{ orgId: string }> }
) {
  const { orgId } = await ctx.params;

  const access = await requireOrgAccess(orgId, { notFoundOnFail: true });
  if (!access.ok) return access.response;

  const org = await prisma.org.findUnique({
    where: { id: orgId },
    select: { id: true, name: true, slug: true, createdAt: true },
  });

  if (!org) {
    return NextResponse.json(
      fail(ErrorCodes.NOT_FOUND, "not_found"),
      { status: 404 }
    );
  }

  return NextResponse.json(ok({ org }));
}

export async function PATCH(
  req: Request,
  ctx: { params: Promise<{ orgId: string }> }
) {
  const { orgId } = await ctx.params;

  const access = await requireOrgAccess(orgId, {
    minRole: "ADMIN",
    notFoundOnFail: true,
  });
  if (!access.ok) return access.response;

  const body = await req.json().catch(() => null);
  const parsed = UpdateOrgSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      fail(
        ErrorCodes.VALIDATION_ERROR,
        "invalid_input",
        parsed.error.flatten()
      ),
      { status: 400 }
    );
  }

  const org = await prisma.org.update({
    where: { id: orgId },
    data: { name: parsed.data.name.trim() },
    select: { id: true, name: true, slug: true },
  });

  return NextResponse.json(ok({ org }));
}

export async function DELETE(
  _req: Request,
  ctx: { params: Promise<{ orgId: string }> }
) {
  const { orgId } = await ctx.params;

  const access = await requireOrgAccess(orgId, {
    minRole: "OWNER",
    notFoundOnFail: true,
  });
  if (!access.ok) return access.response;

  await prisma.org.delete({ where: { id: orgId } });
  return NextResponse.json(ok({}));
}
</file>

<file path="apps/web/src/app/api/orgs/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";

import { prisma } from "@lattice/db";
import { auth } from "@/auth";
import { slugify } from "@/lib/slugify";
import { ok, fail, ErrorCodes } from "@lattice/shared";

export const runtime = "nodejs";

const CreateOrgSchema = z.object({
  name: z.string().min(2).max(80),
});

/**
 * @openapi
 * /api/orgs:
 *   get:
 *     summary: Fetches organizations that belong to the signed-in user.
 *     tags:
 *       - Orgs
 *     responses:
 *       "200":
 *         description: Returns the organizations the user is a member of.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     orgs:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           id:
 *                             type: string
 *                           name:
 *                             type: string
 *                           slug:
 *                             type: string
 *                           createdAt:
 *                             type: string
 *                             format: date-time
 *       "401":
 *         description: Request was not authenticated.
 *   post:
 *     summary: Creates a new organization for the current user.
 *     tags:
 *       - Orgs
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *             required:
 *               - name
 *     responses:
 *       "201":
 *         description: Organization created successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     org:
 *                       type: object
 *                       properties:
 *                         id:
 *                           type: string
 *                         name:
 *                           type: string
 *                         slug:
 *                           type: string
 *       "401":
 *         description: Authentication required.
 *       "400":
 *         description: Validation error.
 */
export async function GET() {
  const session = await auth();
  const userId = session?.user?.id;
  if (!userId) {
    return NextResponse.json(
      fail(ErrorCodes.UNAUTHENTICATED, "unauthorized"),
      { status: 401 }
    );
  }

  const orgs = await prisma.org.findMany({
    where: { members: { some: { userId } } },
    orderBy: { createdAt: "asc" },
    select: { id: true, name: true, slug: true, createdAt: true },
  });

  return NextResponse.json(ok({ orgs }));
}

export async function POST(req: Request) {
  const session = await auth();
  const userId = session?.user?.id;
  if (!userId) {
    return NextResponse.json(
      fail(ErrorCodes.UNAUTHENTICATED, "unauthorized"),
      { status: 401 }
    );
  }

  const body = await req.json().catch(() => null);
  const parsed = CreateOrgSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      fail(
        ErrorCodes.VALIDATION_ERROR,
        "invalid_input",
        parsed.error.flatten()
      ),
      { status: 400 }
    );
  }

  const name = parsed.data.name.trim();
  const base = slugify(name) || "org";
  const slug = await allocateUniqueSlug(base);

  const org = await prisma.org.create({
    data: {
      name,
      slug,
      members: { create: { userId, role: "OWNER" } },
    },
    select: { id: true, name: true, slug: true },
  });

  return NextResponse.json(ok({ org }), { status: 201 });
}

async function allocateUniqueSlug(base: string) {
  let slug = base;
  for (let i = 0; i < 20; i++) {
    const existing = await prisma.org.findUnique({
      where: { slug },
      select: { id: true },
    });
    if (!existing) return slug;
    slug = `${base}-${i + 2}`;
  }
  throw new Error("could_not_allocate_slug");
}
</file>

<file path="apps/web/src/app/globals.css">
@import "tailwindcss";
@import "swagger-ui-react/swagger-ui.css";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
}

:root {
  --radius: 0.625rem;
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="apps/web/src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { AppProviders } from "@/components/providers";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Lattice",
  description: "Privacy-respecting group scheduling — foundations.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <AppProviders>{children}</AppProviders>
      </body>
    </html>
  );
}
</file>

<file path="apps/web/src/features/availability/AvailabilityClient.tsx">
"use client"

import { useEffect, useMemo, useState } from "react"
import { DateTime } from "luxon"
import { toast } from "sonner"

import {
  normalizeIntervals,
  subtractIntervals,
  unionIntervals,
  type Interval,
} from "@/lib/availability/intervals"
import {
  minutesFromTimeString,
  timeStringFromMinutes,
  toUtcIsoFromLocal,
  overrideToLocalIntervalForDate,
} from "@/lib/availability/time"
import { ApiError, fetchJson } from "@/lib/http"

import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"

type WindowDTO = { dayOfWeek: number; startMinute: number; endMinute: number }
type OverrideDTO = {
  id: string
  startAt: string
  endAt: string
  kind: "AVAILABLE" | "UNAVAILABLE"
  note?: string | null
}

const DAYS = [
  { dayOfWeek: 1, label: "Mon" },
  { dayOfWeek: 2, label: "Tue" },
  { dayOfWeek: 3, label: "Wed" },
  { dayOfWeek: 4, label: "Thu" },
  { dayOfWeek: 5, label: "Fri" },
  { dayOfWeek: 6, label: "Sat" },
  { dayOfWeek: 7, label: "Sun" },
]

export default function AvailabilityClient({ orgId }: { orgId: string }) {
  const detectedTZ = useMemo(
    () => Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC",
    [],
  )

  const [timeZone, setTimeZone] = useState<string>(detectedTZ)
  const [windows, setWindows] = useState<WindowDTO[]>([])
  const [overrides, setOverrides] = useState<OverrideDTO[]>([])
  const [previewDate, setPreviewDate] = useState<string>(() => DateTime.now().toISODate()!)

  const [ovDate, setOvDate] = useState<string>(() => DateTime.now().toISODate()!)
  const [ovStart, setOvStart] = useState<string>("09:00")
  const [ovEnd, setOvEnd] = useState<string>("10:00")
  const [ovKind, setOvKind] = useState<"AVAILABLE" | "UNAVAILABLE">("UNAVAILABLE")
  const [ovNote, setOvNote] = useState<string>("")

  const [isLoading, setIsLoading] = useState(true)
  const [isSaving, setIsSaving] = useState(false)
  const [isCreatingOverride, setIsCreatingOverride] = useState(false)
  const [isDeletingOverride, setIsDeletingOverride] = useState(false)
  const [overrideToDelete, setOverrideToDelete] = useState<OverrideDTO | null>(null)

  useEffect(() => {
    void (async () => {
      setIsLoading(true)
      try {
        const [template, overridesData] = await Promise.all([
          fetchJson<{ timeZone?: string; windows?: WindowDTO[] }>(
            `/api/orgs/${orgId}/availability/me/template`,
            { cache: "no-store" },
          ),
          fetchJson<{ overrides?: OverrideDTO[] }>(
            `/api/orgs/${orgId}/availability/me/overrides`,
            { cache: "no-store" },
          ),
        ])

        setTimeZone(template?.timeZone ?? detectedTZ)
        setWindows(template?.windows ?? [])
        setOverrides(overridesData?.overrides ?? [])
      } catch {
        toast.error("Unable to load availability data")
        setWindows([])
        setOverrides([])
      } finally {
        setIsLoading(false)
      }
    })()
  }, [detectedTZ, orgId])

  function addWindow(dayOfWeek: number) {
    setWindows((current) => [
      ...current,
      { dayOfWeek, startMinute: 9 * 60, endMinute: 17 * 60 },
    ])
  }

  function updateWindow(idx: number, patch: Partial<WindowDTO>) {
    setWindows((current) =>
      current.map((window, index) => (index === idx ? { ...window, ...patch } : window)),
    )
  }

  function deleteWindow(idx: number) {
    setWindows((current) => current.filter((_, index) => index !== idx))
  }

  async function saveTemplate() {
    setIsSaving(true)
    try {
      const updated = await fetchJson<{ timeZone: string; windows: WindowDTO[] }>(
        `/api/orgs/${orgId}/availability/me/template`,
        {
          method: "PUT",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ timeZone, windows }),
        },
      )

      setTimeZone(updated.timeZone)
      setWindows(updated.windows)
      toast.success("Weekly template saved")
    } catch (err) {
      const message =
        err instanceof ApiError
          ? err.message
          : err instanceof Error
            ? err.message
            : "Save failed"
      toast.error(`Save failed: ${message}`)
    } finally {
      setIsSaving(false)
    }
  }

  async function createOverride() {
    setIsCreatingOverride(true)
    try {
      const startAt = toUtcIsoFromLocal(ovDate, ovStart, timeZone)
      const endAt = toUtcIsoFromLocal(ovDate, ovEnd, timeZone)

      const json = await fetchJson<{ override: OverrideDTO }>(
        `/api/orgs/${orgId}/availability/me/overrides`,
        {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            startAt,
            endAt,
            kind: ovKind,
            note: ovNote.trim() ? ovNote.trim() : undefined,
          }),
        },
      )

      setOverrides((prev) =>
        [...prev, json.override].sort((a, b) => a.startAt.localeCompare(b.startAt)),
      )
      toast.success("Override added")
    } catch (err) {
      const message =
        err instanceof ApiError
          ? err.message
          : err instanceof Error
            ? err.message
            : "Create failed"
      toast.error(message)
    } finally {
      setIsCreatingOverride(false)
    }
  }

  async function deleteOverride(id: string) {
    setIsDeletingOverride(true)
    try {
      await fetchJson(`/api/orgs/${orgId}/availability/me/overrides/${id}`, {
        method: "DELETE",
      })
      setOverrides((current) => current.filter((override) => override.id !== id))
      toast.success("Override deleted")
      setOverrideToDelete(null)
    } catch (err) {
      const message =
        err instanceof ApiError
          ? err.message
          : err instanceof Error
            ? err.message
            : "Delete failed"
      toast.error(message)
    } finally {
      setIsDeletingOverride(false)
    }
  }

  const effectiveForPreview = useMemo(() => {
    const dt = DateTime.fromISO(previewDate, { zone: timeZone })
    const weekday = dt.weekday

    const base = normalizeIntervals(
      windows
        .filter((w) => w.dayOfWeek === weekday)
        .map((w) => ({ start: w.startMinute, end: w.endMinute })),
    )

    let current: Interval[] = base

    for (const override of overrides) {
      const local = overrideToLocalIntervalForDate(override, previewDate, timeZone)
      if (!local) continue

      if (override.kind === "UNAVAILABLE") current = subtractIntervals(current, [local])
      else current = unionIntervals(current, [local])
    }

    return current
  }, [overrides, previewDate, timeZone, windows])

  return (
    <div className="space-y-8">
      <section className="space-y-4 rounded-2xl border border-border bg-background/70 p-6">
        <div className="flex flex-col gap-1">
          <h2 className="text-xl font-semibold">Weekly template</h2>
          <p className="text-sm text-muted-foreground">
            Configure the hours you are usually available and save a template for the team.
          </p>
        </div>

        <div className="space-y-4">
          <label className="flex flex-col gap-2 text-sm font-medium">
            Time zone
            <Input value={timeZone} onChange={(event) => setTimeZone(event.target.value)} />
          </label>

          {isLoading ? (
            <div className="rounded-lg border border-dashed border-border/70 px-4 py-3">
              <p className="text-sm text-muted-foreground">Loading windows…</p>
            </div>
          ) : (
            <div className="grid gap-4">
              {DAYS.map((day) => {
                const dayWindows = windows
                  .map((win, idx) => ({ ...win, idx }))
                  .filter((win) => win.dayOfWeek === day.dayOfWeek)
                  .sort((a, b) => a.startMinute - b.startMinute)

                return (
                  <div
                    key={day.dayOfWeek}
                    className="rounded-2xl border border-border/70 bg-muted/5 p-4"
                  >
                    <div className="flex items-center justify-between">
                      <h3 className="text-sm font-semibold uppercase tracking-wide text-muted-foreground">
                        {day.label}
                      </h3>
                      <Button
                        variant="ghost"
                        size="sm"
                        type="button"
                        onClick={() => addWindow(day.dayOfWeek)}
                      >
                        + Add window
                      </Button>
                    </div>

                    {dayWindows.length === 0 ? (
                      <p className="mt-3 text-sm text-muted-foreground">No windows yet.</p>
                    ) : (
                      <div className="mt-3 flex flex-col gap-3">
                        {dayWindows.map((win) => (
                          <div
                            key={win.idx}
                            className="flex flex-wrap items-center gap-3"
                          >
                            <Input
                              type="time"
                              value={timeStringFromMinutes(win.startMinute)}
                              onChange={(event) =>
                                updateWindow(win.idx, {
                                  startMinute: minutesFromTimeString(event.target.value) ?? win.startMinute,
                                })
                              }
                              className="w-28"
                            />
                            <span className="text-sm text-muted-foreground">to</span>
                            <Input
                              type="time"
                              value={timeStringFromMinutes(win.endMinute)}
                              onChange={(event) =>
                                updateWindow(win.idx, {
                                  endMinute: minutesFromTimeString(event.target.value) ?? win.endMinute,
                                })
                              }
                              className="w-28"
                            />
                            <Button
                              variant="ghost"
                              size="sm"
                              type="button"
                              onClick={() => deleteWindow(win.idx)}
                            >
                              Delete
                            </Button>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )
              })}
            </div>
          )}
        </div>

        <div className="flex justify-end">
          <Button onClick={saveTemplate} disabled={isSaving || isLoading}>
            {isSaving ? "Saving…" : "Save template"}
          </Button>
        </div>
      </section>

      <section className="space-y-4 rounded-2xl border border-border bg-background/70 p-6">
        <div className="flex flex-col gap-1">
          <h2 className="text-xl font-semibold">Overrides</h2>
          <p className="text-sm text-muted-foreground">
            Add specific dates where your availability differs from the weekly template.
          </p>
        </div>

        <div className="grid gap-4 md:grid-cols-2">
          <label className="flex flex-col gap-2 text-sm font-medium">
            Date
            <Input type="date" value={ovDate} onChange={(event) => setOvDate(event.target.value)} />
          </label>
          <label className="flex flex-col gap-2 text-sm font-medium">
            Start
            <Input type="time" value={ovStart} onChange={(event) => setOvStart(event.target.value)} />
          </label>
          <label className="flex flex-col gap-2 text-sm font-medium">
            End
            <Input type="time" value={ovEnd} onChange={(event) => setOvEnd(event.target.value)} />
          </label>
          <div className="flex flex-col gap-2 text-sm font-medium">
            <span>Kind</span>
            <Select value={ovKind} onValueChange={(value) => setOvKind(value as "AVAILABLE" | "UNAVAILABLE")}>
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Pick a kind" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="AVAILABLE">AVAILABLE (add)</SelectItem>
                <SelectItem value="UNAVAILABLE">UNAVAILABLE (subtract)</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <label className="flex flex-col gap-2 text-sm font-medium md:col-span-2">
            Note (optional)
            <Input value={ovNote} onChange={(event) => setOvNote(event.target.value)} />
          </label>
        </div>
        <div className="flex justify-end">
          <Button onClick={createOverride} disabled={isCreatingOverride}>
            {isCreatingOverride ? "Creating…" : "Create override"}
          </Button>
        </div>

        <div className="space-y-3">
          {overrides.length === 0 ? (
            <p className="text-sm text-muted-foreground">No overrides yet.</p>
          ) : (
            <div className="space-y-2">
              {overrides.map((override) => (
                <div
                  key={override.id}
                  className="flex flex-wrap items-center justify-between gap-2 rounded-xl border border-border/70 bg-muted/5 px-4 py-3"
                >
                  <div className="flex flex-col gap-1 text-sm">
                    <span>
                      <strong>{override.kind}</strong> {override.startAt} → {override.endAt}
                    </span>
                    {override.note ? (
                      <span className="text-xs text-muted-foreground">{override.note}</span>
                    ) : null}
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    type="button"
                    onClick={() => setOverrideToDelete(override)}
                  >
                    Delete
                  </Button>
                </div>
              ))}
            </div>
          )}
        </div>
      </section>

      <section className="space-y-4 rounded-2xl border border-border bg-background/70 p-6">
        <div className="flex flex-col gap-1">
          <h2 className="text-xl font-semibold">Effective availability preview</h2>
          <p className="text-sm text-muted-foreground">
            See how weekly windows and overrides combine for a particular date.
          </p>
        </div>
        <div className="flex flex-col gap-3">
          <label className="flex flex-col gap-2 text-sm font-medium">
            Date
            <Input type="date" value={previewDate} onChange={(event) => setPreviewDate(event.target.value)} />
          </label>
          {effectiveForPreview.length === 0 ? (
            <p className="text-sm text-muted-foreground">No availability for that day.</p>
          ) : (
            <ul className="space-y-2 text-sm">
              {effectiveForPreview.map((interval, index) => (
                <li key={index} className="flex items-center gap-2 rounded-lg border border-border/60 px-3 py-2">
                  <span className="font-semibold">
                    {timeStringFromMinutes(interval.start)} – {timeStringFromMinutes(interval.end)}
                  </span>
                  <span className="text-muted-foreground">({timeZone})</span>
                </li>
              ))}
            </ul>
          )}
        </div>
      </section>

      <Dialog
        open={Boolean(overrideToDelete)}
        onOpenChange={(open) => {
          if (!open) setOverrideToDelete(null)
        }}
      >
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Delete override</DialogTitle>
            <DialogDescription>
              This action cannot be undone. The override will be removed permanently.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="flex flex-wrap gap-2">
            <Button variant="outline" onClick={() => setOverrideToDelete(null)}>
              Cancel
            </Button>
            <Button
              variant="destructive"
              onClick={() => overrideToDelete && deleteOverride(overrideToDelete.id)}
              disabled={isDeletingOverride}
            >
              {isDeletingOverride ? "Deleting…" : "Delete override"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}
</file>

<file path="apps/web/src/features/events/WriteBackButton.tsx">
"use client"

import { useState } from "react"
import { toast } from "sonner"

import { ApiError, fetchJson } from "@/lib/http"
import { Button } from "@/components/ui/button"

export function WriteBackButton(props: { orgId: string; eventId: string }) {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  async function onClick() {
    setIsLoading(true)
    setError(null)

    try {
      await fetchJson(`/api/orgs/${props.orgId}/events/${props.eventId}/writeback/google`, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({}),
      })
      toast.success("Event written to Google Calendar")
    } catch (err) {
      const message = err instanceof ApiError ? err.message : "writeback_failed"
      setError(message)
      toast.error(message)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="space-y-2">
      <Button onClick={onClick} disabled={isLoading}>
        {isLoading ? "Writing to Google..." : "Write to Google Calendar"}
      </Button>
      {error ? <p className="text-sm text-destructive">{error}</p> : null}
    </div>
  )
}
</file>

<file path="apps/web/src/lib/google/calendar.ts">
import { google } from "googleapis";
import type { calendar_v3 } from "googleapis";
import crypto from "crypto";
import { env } from "@/lib/env";
import { decryptString } from "@/lib/crypto/secretbox";

export const GCAL_READ_SCOPES = ["https://www.googleapis.com/auth/calendar.readonly"] as const;
export const GCAL_WRITE_SCOPES = [
  ...GCAL_READ_SCOPES,
  "https://www.googleapis.com/auth/calendar.events",
] as const;

export function getGcalScopes() {
  return env.GCAL_WRITEBACK_ENABLED ? GCAL_WRITE_SCOPES : GCAL_READ_SCOPES;
}
export const MERGED_SOURCE_HASH = crypto.createHash("sha256").update("google:merged").digest("hex");

function assertConfig() {
  if (!env.GCAL_CLIENT_ID || !env.GCAL_CLIENT_SECRET || !env.GCAL_REDIRECT_URI) {
    throw new Error("GCAL_CLIENT_ID/SECRET/REDIRECT_URI are required for calendar integration");
  }
}

export function calendarIdHash(calendarId: string) {
  return crypto.createHash("sha256").update(calendarId + env.AUTH_SECRET).digest("hex");
}

export function blockHash(args: { orgId: string; userId: string; sourceHash: string; startISO: string; endISO: string }) {
  return crypto
    .createHash("sha256")
    .update(`${args.userId}|${args.orgId}|${args.sourceHash}|${args.startISO}|${args.endISO}`)
    .digest("hex");
}

function oauth(refreshTokenCiphertext: string) {
  assertConfig();
  const refreshToken = decryptString(refreshTokenCiphertext);
  const client = new google.auth.OAuth2(env.GCAL_CLIENT_ID, env.GCAL_CLIENT_SECRET, env.GCAL_REDIRECT_URI);
  client.setCredentials({ refresh_token: refreshToken });
  return client;
}

export async function listCalendars(refreshTokenCiphertext: string) {
  const auth = oauth(refreshTokenCiphertext);
  const cal = google.calendar({ version: "v3", auth });

  const out: Array<{ id: string; summary?: string; primary?: boolean; accessRole?: string }> = [];
  let pageToken: string | undefined;

  do {
    const res = await cal.calendarList.list({
      pageToken,
      maxResults: 250,
      fields: "items(id,summary,primary,accessRole),nextPageToken",
    });
    for (const item of res.data.items ?? []) {
      if (!item.id) continue;
      out.push({
        id: item.id,
        summary: item.summary ?? undefined,
        primary: item.primary ?? undefined,
        accessRole: item.accessRole ?? undefined,
      });
    }
    pageToken = res.data.nextPageToken ?? undefined;
  } while (pageToken);

  return out;
}

export async function freeBusy(args: {
  refreshTokenCiphertext: string;
  calendarIds: string[];
  timeMinISO: string;
  timeMaxISO: string;
  timeZone?: string;
}) {
  const auth = oauth(args.refreshTokenCiphertext);
  const cal = google.calendar({ version: "v3", auth });

  const res = await cal.freebusy.query({
    requestBody: {
      timeMin: args.timeMinISO,
      timeMax: args.timeMaxISO,
      timeZone: args.timeZone,
      items: args.calendarIds.map((id) => ({ id })),
    },
  });

  return res.data.calendars ?? {};
}

export function mergeUtcIntervals(intervals: Array<{ startUtc: Date; endUtc: Date }>) {
  const sorted = intervals
    .filter((i) => i.startUtc < i.endUtc)
    .sort((a, b) => a.startUtc.getTime() - b.startUtc.getTime());
  const merged: Array<{ startUtc: Date; endUtc: Date }> = [];
  for (const cur of sorted) {
    const last = merged[merged.length - 1];
    if (!last) {
      merged.push(cur);
      continue;
    }
    if (cur.startUtc.getTime() <= last.endUtc.getTime()) {
      last.endUtc = new Date(Math.max(last.endUtc.getTime(), cur.endUtc.getTime()));
    } else merged.push(cur);
  }
  return merged;
}

export async function createGoogleCalendarEvent(args: {
  refreshTokenCiphertext: string;
  calendarId: string;
  summary: string;
  description?: string;
  startISO: string;
  endISO: string;
  timeZone: string;
  attendees?: Array<{ email: string }>;
  sendUpdates?: "all" | "externalOnly" | "none";
}) {
  const auth = oauth(args.refreshTokenCiphertext);
  const cal = google.calendar({ version: "v3", auth });

  const res = await cal.events.insert({
    calendarId: args.calendarId,
    sendUpdates: args.sendUpdates ?? "none",
    requestBody: {
      summary: args.summary,
      description: args.description,
      start: { dateTime: args.startISO, timeZone: args.timeZone },
      end: { dateTime: args.endISO, timeZone: args.timeZone },
      attendees: args.attendees,
    },
  });

  return res.data as calendar_v3.Schema$Event;
}
</file>

<file path="apps/web/src/lib/suggestions/engine.test.ts">
import { describe, expect, it } from "vitest"
import { generateSuggestions } from "./engine"
import type { OverrideDTO, WindowDTO } from "./engine"

function makeAttendee(userId: string, timeZone: string, windows: WindowDTO[], overrides: OverrideDTO[] = []) {
  return { userId, timeZone, windows, overrides }
}

describe("generateSuggestions", () => {
  it("is deterministic with tie-breakers", () => {
    const attendees = [
      makeAttendee("a", "America/New_York", [{ dayOfWeek: 2, startMinute: 9 * 60, endMinute: 17 * 60 }]),
      makeAttendee("b", "America/New_York", [{ dayOfWeek: 2, startMinute: 9 * 60, endMinute: 17 * 60 }]),
    ]

    const res1 = generateSuggestions({
      timeZone: "America/New_York",
      rangeStart: "2026-01-13",
      rangeEnd: "2026-01-13",
      durationMinutes: 30,
      stepMinutes: 30,
      dayStartMinute: 9 * 60,
      dayEndMinute: 11 * 60,
      attendees,
      maxCandidates: 10,
    })

    const res2 = generateSuggestions({
      timeZone: "America/New_York",
      rangeStart: "2026-01-13",
      rangeEnd: "2026-01-13",
      durationMinutes: 30,
      stepMinutes: 30,
      dayStartMinute: 9 * 60,
      dayEndMinute: 11 * 60,
      attendees,
      maxCandidates: 10,
    })

    expect(res1).toEqual(res2)
    expect(res1[0]?.rank).toBe(1)
  })

  it("respects attendee time zones", () => {
    const ny = makeAttendee("ny", "America/New_York", [{ dayOfWeek: 2, startMinute: 9 * 60, endMinute: 10 * 60 }])
    const la = makeAttendee("la", "America/Los_Angeles", [{ dayOfWeek: 2, startMinute: 9 * 60, endMinute: 10 * 60 }])

    const res = generateSuggestions({
      timeZone: "America/New_York",
      rangeStart: "2026-01-13",
      rangeEnd: "2026-01-13",
      durationMinutes: 30,
      stepMinutes: 30,
      dayStartMinute: 9 * 60,
      dayEndMinute: 10 * 60,
      attendees: [ny, la],
      maxCandidates: 10,
    })

    expect(res.length).toBeGreaterThan(0)
    expect(res[0].missingUserIds).toContain("la")
  })

  it("applies UNAVAILABLE overrides", () => {
    const attendee = makeAttendee(
      "u",
      "America/New_York",
      [{ dayOfWeek: 2, startMinute: 9 * 60, endMinute: 12 * 60 }],
      [
        {
          startAt: "2026-01-13T15:00:00.000Z",
          endAt: "2026-01-13T16:00:00.000Z",
          kind: "UNAVAILABLE",
        },
      ],
    )

    const res = generateSuggestions({
      timeZone: "America/New_York",
      rangeStart: "2026-01-13",
      rangeEnd: "2026-01-13",
      durationMinutes: 30,
      stepMinutes: 30,
      dayStartMinute: 9 * 60,
      dayEndMinute: 12 * 60,
      attendees: [attendee],
      maxCandidates: 20,
    })

    expect(res.some((candidate) => candidate.startAt === "2026-01-13T15:00:00.000Z")).toBe(false)
  })
})
</file>

<file path="apps/web/src/lib/guards.ts">
import { NextResponse } from "next/server";

import { auth } from "@/auth";
import { prisma } from "@lattice/db";
import { fail, ErrorCodes } from "@lattice/shared";
import { roleAtLeast, type OrgRole } from "@/lib/rbac";

export async function requireUserId(): Promise<string> {
  const session = await auth();
  const userId = session?.user?.id;
  if (!userId) throw new Error("UNAUTHORIZED");
  return userId;
}

/**
 * Membership guard that avoids “soft leaks” by defaulting to 404.
 *
 * Guidance:
 * - Use 404 when the user is not a member (don’t confirm org existence).
 * - Use 403 when the user is a member but lacks permissions.
 */
export async function requireMembership(
  orgId: string,
  opts?: { minRole?: OrgRole; notFoundOnFail?: boolean }
) {
  const userId = await requireUserId();

  const membership = await prisma.membership.findUnique({
    where: { orgId_userId: { orgId, userId } },
    select: { id: true, role: true, orgId: true, userId: true },
  });

  if (!membership) {
    const notFoundOnFail = opts?.notFoundOnFail ?? true;
    return {
      ok: false as const,
      status: notFoundOnFail ? 404 : 403,
      membership: null,
    };
  }

  if (opts?.minRole && !roleAtLeast(membership.role as OrgRole, opts.minRole)) {
    return { ok: false as const, status: 403, membership };
  }

  return { ok: true as const, status: 200, membership };
}

type MembershipRecord = NonNullable<
  Awaited<ReturnType<typeof requireMembership>>["membership"]
>;

type OrgAccessSuccess = { ok: true; membership: MembershipRecord };
type OrgAccessFailure = { ok: false; response: NextResponse };

export async function requireOrgAccess(
  orgId: string,
  opts?: { minRole?: OrgRole; notFoundOnFail?: boolean }
): Promise<OrgAccessSuccess | OrgAccessFailure> {
  const access = await requireMembership(orgId, opts);

  if (!access.ok) {
    const code =
      access.status === 403 ? ErrorCodes.FORBIDDEN : ErrorCodes.NOT_FOUND;
    const message = access.status === 403 ? "forbidden" : "not_found";
    return {
      ok: false,
      response: NextResponse.json(fail(code, message), { status: access.status }),
    };
  }

  return { ok: true, membership: access.membership! };
}
</file>

<file path="apps/web/src/middleware.ts">
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { getToken } from "next-auth/jwt";

export async function middleware(req: NextRequest) {
  if (process.env.PLAYWRIGHT_TEST === "1") return NextResponse.next();

  const { pathname } = req.nextUrl;

  if (
    pathname.startsWith("/signin") ||
    pathname.startsWith("/api/auth") ||
    pathname.startsWith("/_next") ||
    pathname === "/favicon.ico"
  ) {
    return NextResponse.next();
  }

  const token = await getToken({ req, secret: process.env.AUTH_SECRET });
  if (!token) {
    const url = req.nextUrl.clone();
    url.pathname = "/signin";
    url.searchParams.set("callbackUrl", pathname);
    return NextResponse.redirect(url);
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/((?!api/auth|_next/static|_next/image|favicon.ico).*)"],
};
</file>

<file path="apps/web/next.config.ts">
import path from "path";
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  turbopack: {},
  transpilePackages: ["@lattice/db", "@lattice/shared"],
  webpack: (config) => {
    config.resolve = config.resolve ?? {};
    config.resolve.alias = {
      ...config.resolve.alias,
      "@lattice/shared": path.resolve(__dirname, "../../packages/shared/src/index.ts"),
      "@lattice/db": path.resolve(__dirname, "../../packages/db/src/index.ts"),
    };
    return config;
  },
};

export default nextConfig;
</file>

<file path="apps/web/playwright.config.ts">
import { defineConfig } from "@playwright/test";

export default defineConfig({
  testDir: "tests/e2e",
  webServer: {
    command: "pnpm dev",
    env: {
      SUGGESTIONS_ENABLED: "1",
      EVENTS_ENABLED: "1",
    },
    url: "http://localhost:3000",
    reuseExistingServer: !process.env.CI,
    timeout: 120_000,
  },
});
</file>

<file path="packages/db/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- Auth.js / NextAuth models (Prisma Adapter-compatible) ---
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  memberships   Membership[]
  calendarConnections CalendarConnection[]
  busyBlocks          BusyBlock[]
  syncRuns            CalendarSyncRun[]
  auditLogs           AuditLog[] @relation("UserAuditLogs")

  availabilityTemplates AvailabilityTemplate[]
  availabilityOverrides AvailabilityOverride[]
  createdSuggestionRequests SuggestionRequest[]
  suggestionRequestAttendees SuggestionRequestAttendee[]
  scheduledEventAttendees ScheduledEventAttendee[]
  createdScheduledEvents ScheduledEvent[] @relation("ScheduledEventCreatedBy")
  confirmedScheduledEvents ScheduledEvent[] @relation("ScheduledEventConfirmedBy")

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// --- Multi-tenant placeholders (Phase 1 will use these) ---
model Org {
  id        String       @id @default(cuid())
  name      String
  slug      String       @unique
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  members   Membership[]
  calendarSelections CalendarSelection[]
  busyBlocks BusyBlock[]
  syncRuns   CalendarSyncRun[]
  suggestionRequests SuggestionRequest[]
  availabilityTemplates AvailabilityTemplate[]
  availabilityOverrides AvailabilityOverride[]
  scheduledEvents ScheduledEvent[]
  idempotencyKeys IdempotencyKey[]
  auditLogs         AuditLog[] @relation("OrgAuditLogs")
}

model AuditLog {
  id           String      @id @default(cuid())
  orgId        String
  actorUserId  String?
  action       AuditAction
  targetType   String?
  targetId     String?
  metadata     Json?
  createdAt    DateTime    @default(now())

  org        Org  @relation("OrgAuditLogs", fields: [orgId], references: [id], onDelete: Cascade)
  actorUser  User? @relation("UserAuditLogs", fields: [actorUserId], references: [id], onDelete: SetNull)

  @@index([orgId, createdAt])
  @@index([orgId, action, createdAt])
}

model Membership {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  role      Role     @default(MEMBER)
  createdAt DateTime @default(now())

  org  Org  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, userId])
}

enum Role {
  OWNER
  ADMIN
  LEADER
  MEMBER
}

enum AuditAction {
  ORG_CREATED
  MEMBER_INVITED
  MEMBER_ROLE_UPDATED
  MEMBER_REMOVED
  AVAILABILITY_TEMPLATE_UPDATED
  AVAILABILITY_OVERRIDE_CREATED
  AVAILABILITY_OVERRIDE_DELETED
  CALENDAR_CONNECTED
  CALENDAR_DISCONNECTED
  CALENDAR_SYNC_STARTED
  CALENDAR_SYNC_SUCCESS
  CALENDAR_SYNC_FAILURE
  SUGGESTION_REQUEST_CREATED
  SLOT_CONFIRMED
  WRITEBACK_ATTEMPTED
  ACCEPTANCE_CHECK
}

// --- Phase 2: Availability ---

enum AvailabilityOverrideKind {
  AVAILABLE
  UNAVAILABLE
}

model AvailabilityTemplate {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  timeZone  String   @default("UTC")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org    Org  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  windows AvailabilityWindow[]

  @@unique([orgId, userId])
  @@index([orgId])
  @@index([userId])
}

model AvailabilityWindow {
  id         String @id @default(cuid())
  templateId String
  dayOfWeek  Int    // 1=Mon ... 7=Sun (Luxon weekday)
  startMinute Int   // 0..1439
  endMinute   Int   // 1..1440

  template AvailabilityTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@index([templateId])
  @@index([dayOfWeek])
}

enum CalendarProvider {
  GOOGLE
}

enum CalendarConnectionStatus {
  ACTIVE
  REVOKED
  ERROR
}

model CalendarConnection {
  id                    String   @id @default(cuid())
  userId                String
  provider              CalendarProvider
  scopes                String
  encryptedRefreshToken String
  status                CalendarConnectionStatus @default(ACTIVE)
  lastSyncAt            DateTime?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user       User @relation(fields: [userId], references: [id], onDelete: Cascade)
  selections CalendarSelection[]
  syncRuns   CalendarSyncRun[]

  @@unique([userId, provider])
}

model CalendarSelection {
  id             String   @id @default(cuid())
  connectionId   String
  orgId          String
  calendarIdHash String   // sha256(calendarId + AUTH_SECRET)
  isBusySource   Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  connection CalendarConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  org        Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([connectionId, orgId, calendarIdHash])
}

model BusyBlock {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  provider  CalendarProvider
  sourceHash String // hashed, never raw IDs
  startUtc  DateTime
  endUtc    DateTime
  blockHash String  @unique // sha256(userId|orgId|sourceHash|start|end)
  createdAt DateTime @default(now())

  org  Org  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId, userId, startUtc])
}

model CalendarSyncRun {
  id            String   @id @default(cuid())
  orgId         String
  userId        String
  connectionId  String
  provider      CalendarProvider
  rangeStartUtc DateTime
  rangeEndUtc   DateTime
  status        String   // STARTED | SUCCESS | ERROR
  errorCode     String?
  errorDetail   String?
  startedAt     DateTime @default(now())
  finishedAt    DateTime?

  org        Org                @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user       User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  connection CalendarConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@index([orgId, userId, startedAt])
}

model AvailabilityOverride {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  startAt   DateTime
  endAt     DateTime
  kind      AvailabilityOverrideKind
  note      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org  Org  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId, startAt])
  @@index([userId, startAt])
  @@index([orgId, userId, startAt])
}

model SuggestionRequest {
  id             String   @id @default(cuid())
  orgId          String
  createdById    String
  requestKey     String
  title          String?
  timeZone       String
  rangeStart     DateTime
  rangeEnd       DateTime
  durationMinutes Int
  stepMinutes     Int      @default(15)
  dayStartMinute  Int      @default(480)
  dayEndMinute    Int      @default(1200)
  dataFingerprint String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  org      Org                    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  createdBy User                 @relation(fields: [createdById], references: [id], onDelete: Cascade)
  attendees SuggestionRequestAttendee[]
  candidates SuggestionCandidate[]
  scheduledEvents ScheduledEvent[] @relation("ScheduledEventSuggestionRequest")

  @@unique([orgId, requestKey])
  @@index([orgId, createdAt])
}

model SuggestionRequestAttendee {
  id        String @id @default(cuid())
  requestId String
  userId    String

  request SuggestionRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  user    User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([requestId, userId])
  @@index([userId])
}

model SuggestionCandidate {
  id               String   @id @default(cuid())
  requestId        String
  rank             Int
  startAt          DateTime
  endAt            DateTime
  attendanceRatio  Float
  scoreTotal         Float
  scoreAttendance    Float
  scoreInconvenience Float
  scoreFairness      Float
  availableUserIds String[]
  missingUserIds   String[]
  explanation      Json
  createdAt        DateTime @default(now())

  request SuggestionRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@index([requestId, rank])
  @@index([startAt])
}

model IdempotencyKey {
  id             String   @id @default(cuid())
  orgId          String
  key            String
  endpoint       String
  requestHash    String
  responseStatus Int?
  responseBody   Json?
  createdAt      DateTime @default(now())
  expiresAt      DateTime

  org Org @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, endpoint, key])
  @@index([expiresAt])
}

enum ScheduledEventStatus {
  CONFIRMED
  CANCELLED
}

enum RsvpStatus {
  INVITED
  ACCEPTED
  DECLINED
  TENTATIVE
}

enum WriteBackStatus {
  NOT_REQUESTED
  PENDING
  SUCCESS
  ERROR
}

model ScheduledEvent {
  id        String              @id @default(cuid())
  orgId     String
  org       Org                 @relation(fields: [orgId], references: [id], onDelete: Cascade)

  title     String
  notes     String?
  startUtc  DateTime
  endUtc    DateTime
  timeZone  String

  status    ScheduledEventStatus @default(CONFIRMED)

  sourceRequestId     String?
  sourceCandidateRank Int?
  suggestionRequest   SuggestionRequest? @relation("ScheduledEventSuggestionRequest", fields: [sourceRequestId], references: [id], onDelete: SetNull)

  createdById  String
  createdBy    User    @relation("ScheduledEventCreatedBy", fields: [createdById], references: [id], onDelete: Restrict)

  confirmedById String
  confirmedBy   User   @relation("ScheduledEventConfirmedBy", fields: [confirmedById], references: [id], onDelete: Restrict)

  writeBackStatus       WriteBackStatus @default(NOT_REQUESTED)
  externalProvider      String?
  externalCalendarId    String?
  externalEventId       String?
  externalEventHtmlLink String?
  writeBackError        String?

  attendees ScheduledEventAttendee[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orgId, startUtc])
  @@unique([sourceRequestId, sourceCandidateRank])
}

model ScheduledEventAttendee {
  id      String @id @default(cuid())
  eventId String
  event   ScheduledEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  rsvp RsvpStatus @default(INVITED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, userId])
  @@index([userId])
}
</file>

<file path="packages/db/src/index.ts">
import { PrismaClient, Prisma } from "@prisma/client";

const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log:
      process.env.NODE_ENV === "development"
        ? ["query", "error", "warn"]
        : ["error"],
  });

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

export { Prisma };
</file>

<file path="packages/shared/src/http/rate-limit.ts">
import { fail } from "./envelope";
import { ErrorCodes } from "./error-codes";
import { getRedisClient } from "../redis/client";

type PolicyConfig = {
  limit: number;
  windowSeconds: number;
};

export const RateLimitPolicies = {
  auth: { limit: 10, windowSeconds: 60 },
  suggestions: { limit: 30, windowSeconds: 60 },
  sync: { limit: 6, windowSeconds: 3600 },
  membership: { limit: 20, windowSeconds: 3600 },
  // add more scopes here as needed
} as const;

export type RateLimitScope = keyof typeof RateLimitPolicies;

const KEY_PREFIX = "rl";

function sanitizeSegment(segment: string | number) {
  return encodeURIComponent(String(segment));
}

export function buildRateLimitKey(scope: RateLimitScope, segments: Array<string | number>) {
  const parts = [KEY_PREFIX, scope, ...segments.map(sanitizeSegment)];
  return parts.join(":");
}

const IP_HEADER_PRIORITY = [
  "x-forwarded-for",
  "x-real-ip",
  "cf-connecting-ip",
  "true-client-ip",
  "fastly-client-ip",
  "x-cluster-client-ip",
];

function parseForwardedHeader(value: string) {
  const match = value.match(/for=("[^"]+"|[^;,\s]+)/i);
  if (!match || !match[1]) return "";
  return match[1].replace(/^"|"$/g, "");
}

export function getRequestIp(req: Request) {
  for (const header of IP_HEADER_PRIORITY) {
    const value = req.headers.get(header);
    if (!value) continue;
    const rawIp = value.split(",")[0];
    if (!rawIp) continue;
    const ip = rawIp.trim();
    if (ip) return ip;
  }

  const forwarded = req.headers.get("forwarded");
  if (forwarded) {
    const parsed = parseForwardedHeader(forwarded);
    if (parsed) return parsed;
  }

  return "unknown";
}

export type RateLimitResult =
  | { allowed: true }
  | {
      allowed: false;
      response: ReturnType<typeof fail>;
      retryAfterSeconds: number;
      policy: PolicyConfig;
    };

export async function enforceRateLimit(scope: RateLimitScope, key: string): Promise<RateLimitResult> {
  const policy = RateLimitPolicies[scope];

  const redisClient = await getRedisClient().catch(() => null);
  if (!redisClient) {
    return { allowed: true };
  }

  try {
    await redisClient.set(key, "0", { NX: true, EX: policy.windowSeconds });
    const count = await redisClient.incr(key);
    let ttl = await redisClient.ttl(key);

    if (ttl < 0) {
      await redisClient.expire(key, policy.windowSeconds);
      ttl = policy.windowSeconds;
    }

    if (count > policy.limit) {
      const retryAfterSeconds = Math.max(ttl, 0);

      return {
        allowed: false,
        response: fail(
          ErrorCodes.RATE_LIMITED,
          "rate_limit_exceeded",
          {
            scope,
            limit: policy.limit,
            windowSeconds: policy.windowSeconds,
            retryAfterSeconds,
          }
        ),
        retryAfterSeconds,
        policy,
      };
    }

    return { allowed: true };
  } catch (error) {
    console.warn("[rate-limit] failed to enforce limit", error);
    return { allowed: true };
  }
}

export function buildRetryAfterHeader(retryAfterSeconds: number) {
  const value = Math.max(Math.ceil(retryAfterSeconds), 1);
  return { "Retry-After": value.toString() };
}
</file>

<file path="packages/shared/src/redis/client.ts">
import { createClient } from "redis";

import { env } from "../env";

type RedisClient = ReturnType<typeof createClient>;

let client: RedisClient | null = null;
let connecting: Promise<RedisClient | null> | null = null;

export async function getRedisClient(): Promise<RedisClient | null> {
  if (!env.REDIS_URL) {
    return null;
  }

  if (client) {
    return client;
  }

  if (connecting) {
    return connecting;
  }

  connecting = (async () => {
    const nextClient = createClient({ url: env.REDIS_URL });
    nextClient.on("error", (error) => {
      console.warn("[redis] connection error", error);
    });

    try {
      await nextClient.connect();
      client = nextClient;
      return client;
    } catch (error) {
      console.warn("[redis] failed to connect", error);
      return null;
    } finally {
      connecting = null;
    }
  })();

  return connecting;
}
</file>

<file path="packages/shared/src/env.ts">
import { z } from "zod";

const boolishString = z
  .string()
  .optional()
  .default("0")
  .transform((value) => {
    const normalized = value?.toLowerCase() ?? "";
    return normalized === "1" || normalized === "true";
  });

// NOTE: keep Phase 0 minimal. Expand as you add features.
export const EnvSchema = z.object({
  NODE_ENV: z.enum(["development", "test", "production"]).default("development"),
  DATABASE_URL: z.string().url(),
  REDIS_URL: z.string().optional(),
  AUTH_SECRET: z.string().min(10),
  AUTH_GOOGLE_ID: z.string().optional().or(z.literal("")),
  AUTH_GOOGLE_SECRET: z.string().optional().or(z.literal("")),
  RESEND_API_KEY: z.string().optional(),
  SENTRY_DSN: z.string().optional(),
  GCAL_CLIENT_ID: z.string().optional().or(z.literal("")).default(""),
  GCAL_CLIENT_SECRET: z.string().optional().or(z.literal("")).default(""),
  GCAL_REDIRECT_URI: z.string().optional().or(z.literal("")).default(""),
  TOKEN_ENC_KEY: z.string().optional().or(z.literal("")).default(""),
  SUGGESTIONS_ENABLED: boolishString,
  EVENTS_ENABLED: boolishString,
  GCAL_WRITEBACK_ENABLED: boolishString,
});

export type Env = z.infer<typeof EnvSchema>;

export function parseEnv(raw: Record<string, string | undefined>): Env {
  return EnvSchema.parse(raw);
}

export const env = parseEnv(process.env as Record<string, string | undefined>);
</file>

<file path="packages/shared/src/index.ts">
export * from "./env";
export * from "./http/envelope";
export * from "./http/error-codes";
export * from "./http/rate-limit";
export * from "./redis/client";
export * from "./audit/log";
</file>

<file path="packages/shared/package.json">
{
  "name": "@lattice/shared",
  "private": true,
  "version": "0.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "tsup src/index.ts --format esm,cjs",
    "lint": "eslint .",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "test": "echo \"(no tests yet)\""
  },
  "dependencies": {
    "@lattice/db": "workspace:*",
    "redis": "^4.7.1",
    "zod": "^3.0.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "eslint": "^9.0.0",
    "tsup": "^8.0.0",
    "typescript": "^5.0.0"
  }
}
</file>

<file path="packages/shared/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src/**/*.ts", "../../types/**/*.d.ts"]
}
</file>

<file path="package.json">
{
  "name": "lattice",
  "private": true,
  "packageManager": "pnpm@9.0.0",
  "engines": {
    "node": ">=20"
  },
  "scripts": {
    "dev": "pnpm -C apps/web dev",
    "build": "pnpm -r build",
    "lint": "pnpm -r lint",
    "typecheck": "pnpm -r typecheck",
    "test": "pnpm -r test",
    "format": "prettier . --write",
    "format:check": "prettier . --check",
    "db:up": "docker compose up -d",
    "db:down": "docker compose down",
    "db:logs": "docker compose logs -f",
    "db:generate": "pnpm --filter ./packages/db run prisma:generate",
    "db:migrate": "pnpm --filter ./packages/db run prisma:migrate",
    "db:seed": "pnpm --filter ./packages/db exec prisma db seed",
    "db:reset": "pnpm --filter ./packages/db exec prisma migrate reset --force",
    "db:studio": "pnpm --filter ./packages/db run prisma:studio"
  },
  "devDependencies": {
    "@typescript-eslint/parser": "8.52.0",
    "node-addon-api": "8.5.0",
    "prettier": "3.7.4",
    "prettier-plugin-tailwindcss": "0.7.2"
  }
}
</file>

<file path="README.md">
# Lattice
Privacy-respecting scheduling for groups and teams that need to coordinate without sacrificing control or trust.

## What makes this project special

- **Privacy-first defaults** – calendars, availability, and suggestions are never exposed unless explicitly shared; encryption helpers keep tokens secure when enabled.
- **Intelligent coordination** – a fairness engine evaluates slot proposals so every member has a voice, even in biased calendars.
- **Modular stack** – a Next.js frontend/API pair works with Prisma-backed data, shared types, and helper packages to keep logic centralized.

## Getting started

### Prerequisites

- Node.js **20.x** or newer (see `engines.node` in `package.json`)
- [pnpm](https://pnpm.io/) (the repo relies on the workspace-aware CLI)
- Docker & Docker Compose (Postgres + Redis run in containers during local development)

### Quick setup

1. `pnpm install` – install workspace dependencies.
2. `cp .env.example .env.local` and fill in any secrets (at minimum set `AUTH_SECRET` to a strong string).
3. `pnpm -w db:up` – boot Postgres and Redis containers described in `docker-compose.yml`.
4. `pnpm -w db:generate` – refresh the Prisma client before any migration.
5. `pnpm -w db:migrate` – bring the database schema up to date.
6. `pnpm dev` – start the Next.js dev server from `apps/web`.

Health check: [http://localhost:3000/api/health](http://localhost:3000/api/health)

### Environment notes

- `DATABASE_URL` / `REDIS_URL` point at the local services started by Docker Compose.
- `AUTH_SECRET` is required for NextAuth; keep it long and random.
- Feature flags such as `SUGGESTIONS_ENABLED` and `EVENTS_ENABLED` live in the `.env` values so you can toggle preview features without code changes.
- When Google Calendar support is needed, populate the `GCAL_*` values plus `TOKEN_ENC_KEY` for encryption-aware flows.

## Database tooling

- `pnpm -w db:seed` – seed the Postgres/PostGIS dataset with demo data.
- `pnpm -w db:reset` – drop and recreate the schema when migrations diverge from the state machine.
- `pnpm -w db:studio` – launch Prisma Studio at `http://localhost:5555` for quick inspection.
- `pnpm -w db:logs` – tail the Docker logs for both Postgres and Redis.
- `pnpm -w db:down` – stop and remove the containers once you are done.

## Development workflow

- `pnpm -w dev` (`pnpm dev` from the root) – runs the Next.js app (UI + API routes) for live editing.
- `pnpm -w lint` – lint the entire workspace.
- `pnpm -w typecheck` – run TypeScript checks across the workspace.
- `pnpm -w test` – execute automated test suites (unit, integration, etc.).
- `pnpm -w build` – produce production-ready artifacts for each package/app.
- `pnpm format` / `pnpm format:check` – apply or verify Prettier formatting (includes Tailwind plugin).

> The root `package.json` scripts wrap workspace commands so you only need to run `pnpm <script>` at the root; workspace scope (`-w`) is applied where appropriate.

## Repository layout

- `apps/web` – Next.js + App Router powering the public UI, API handling, and auth routes.
- `packages/db` – Prisma schema, migrations, and helpers for database access. The `package.json` exposes Prisma commands consumed by the root scripts.
- `packages/shared` – shared types, environment validation logic, and helpers that keep backend and frontend in sync.
- `docs/` – architectural decisions, API surface, fairness engine notes, and the threat model for decisions requiring context.

## Documentation

- `docs/api.md` – API surface and contract expectations.
- `docs/architecture.md` – overall system design, data flow, and service boundaries.
- `docs/fairness-engine.md` – rationale and mathematics behind the suggestion ranking strategy.
- `docs/threat-model.md` – security assumptions, mitigations, and adversary models for scheduling data.
- `docs/adr/` – architectural decision records that capture why big choices were made.

## Contributing & support

- Follow `CONTRIBUTING.md` for branching, testing, and review guidelines.
- Respect the behavior outlined in `CODE_OF_CONDUCT.md`.
- Need to fix a bug or add a feature? Start by opening an issue with steps to reproduce or a detailed proposal.

## Next steps

1. Run the full test suite (`pnpm -w test`) after completing your changes.
2. Keep documentation in sync whenever a public API, database schema, or env contract changes.
3. When in doubt, consult the docs above; file an ADR if you diverge from an existing decision.
</file>

<file path="SECURITY.md">
# Security Policy

## Reporting a vulnerability
Please do not open public issues for security reports. Send a confidential email to `security@lattice.dev` with the subject `Security issue: <brief description>` or use any private advisory channel we share.

We aim to acknowledge receipt within 3 business days and keep you updated on progress until the issue is resolved.

## What to include
- Steps to reproduce the vulnerability or a runnable demo repository.
- Impacted versions (apps/packages/commit hashes) and the severity you observe.
- Screenshots, logs, or crash reports that clarify the issue.
- Any mitigations or temporary workarounds you already tried.

## Response timeline
- **Acknowledgement:** within 3 business days.
- **Investigation:** we'll provide status updates if we expect more than a week to resolve.
- **Resolution:** we'll document the fix before making a release and confirm with you when the fix is published.

## Secrets
- Never commit `.env*` files except `.env.example`.
- Rotate any secrets or API keys immediately if they are exposed.

## Data
- Calendar tokens, availability payloads, and other personal data are considered sensitive.
- Avoid logging OAuth tokens, full calendar responses, or any personally identifiable information.
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/availability/me/overrides/route.ts">
import { NextRequest, NextResponse } from "next/server"
import { z } from "zod"

import { prisma } from "@lattice/db"
import { fail, ok, ErrorCodes, logAudit, AuditActions } from "@lattice/shared"
import { requireOrgAccess } from "@/lib/guards"

export const runtime = "nodejs"

const BodySchema = z
  .object({
    startAt: z.string().datetime(),
    endAt: z.string().datetime(),
    kind: z.enum(["AVAILABLE", "UNAVAILABLE"]),
    note: z.string().max(200).optional(),
  })
  .refine((b) => new Date(b.startAt).getTime() < new Date(b.endAt).getTime(), "startAt must be < endAt")

/**
 * @openapi
 * /api/orgs/{orgId}/availability/me/overrides:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   get:
 *     summary: Lists override intervals optionally filtered by range.
 *     tags:
 *       - Availability
 *     parameters:
 *       - name: from
 *         in: query
 *         schema:
 *           type: string
 *           format: date-time
 *       - name: to
 *         in: query
 *         schema:
 *           type: string
 *           format: date-time
 *     responses:
 *       "200":
 *         description: Overrides for the authenticated user.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     overrides:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           id:
 *                             type: string
 *                           startAt:
 *                             type: string
 *                             format: date-time
 *                           endAt:
 *                             type: string
 *                             format: date-time
 *                           kind:
 *                             type: string
 *                           note:
 *                             type: string
 *   post:
 *     summary: Adds a new availability override for the authenticated user.
 *     tags:
 *       - Availability
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               startAt:
 *                 type: string
 *                 format: date-time
 *               endAt:
 *                 type: string
 *                 format: date-time
 *               kind:
 *                 type: string
 *                 enum:
 *                   - AVAILABLE
 *                   - UNAVAILABLE
 *               note:
 *                 type: string
 *             required:
 *               - startAt
 *               - endAt
 *               - kind
 *     responses:
 *       "200":
 *         description: Override created.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     override:
 *                       type: object
 *                       properties:
 *                         id:
 *                           type: string
 *                         startAt:
 *                           type: string
 *                           format: date-time
 *                         endAt:
 *                           type: string
 *                           format: date-time
 *                         kind:
 *                           type: string
 *                         note:
 *                           type: string
 *       "400":
 *         description: Validation error.
 *       "401":
 *         description: Authentication required.
 */
function respondUnauthorized() {
  return NextResponse.json(
    fail(ErrorCodes.UNAUTHENTICATED, "unauthorized"),
    { status: 401 }
  )
}

type OverrideFilter = {
  orgId: string
  userId: string
  AND?: Array<{ endAt?: { gte: Date }; startAt?: { lt: Date } }>
}

export async function GET(req: NextRequest, { params }: { params: Promise<{ orgId: string }> }) {
  const { orgId } = await params

  try {
    const access = await requireOrgAccess(orgId, { notFoundOnFail: true })
    if (!access.ok) return access.response

    const userId = access.membership.userId

    const url = new URL(req.url)
    const from = url.searchParams.get("from")
    const to = url.searchParams.get("to")

    const where: OverrideFilter = { orgId, userId }
    if (from || to) {
      where.AND = []
      if (from) where.AND.push({ endAt: { gte: new Date(from) } })
      if (to) where.AND.push({ startAt: { lt: new Date(to) } })
    }

    const overrides = await prisma.availabilityOverride.findMany({
      where,
      orderBy: { startAt: "asc" },
    })

    return NextResponse.json(
      ok({
        overrides: overrides.map((o) => ({
          id: o.id,
          startAt: o.startAt.toISOString(),
          endAt: o.endAt.toISOString(),
          kind: o.kind,
          note: o.note,
        })),
      })
    )
  } catch {
    return respondUnauthorized()
  }
}

export async function POST(req: NextRequest, { params }: { params: Promise<{ orgId: string }> }) {
  const { orgId } = await params

  try {
    const access = await requireOrgAccess(orgId)
    if (!access.ok) return access.response

    const userId = access.membership.userId

    const json = await req.json().catch(() => null)
    const parsed = BodySchema.safeParse(json)
    if (!parsed.success) {
      return NextResponse.json(
        fail(
          ErrorCodes.VALIDATION_ERROR,
          "Invalid body",
          parsed.error.flatten()
        ),
        { status: 400 }
      )
    }

    const created = await prisma.availabilityOverride.create({
      data: {
        orgId,
        userId,
        startAt: new Date(parsed.data.startAt),
        endAt: new Date(parsed.data.endAt),
        kind: parsed.data.kind,
        note: parsed.data.note,
      },
    })

    await logAudit({
      orgId,
      actorUserId: userId,
      action: AuditActions.AVAILABILITY_OVERRIDE_CREATED,
      targetType: "AvailabilityOverride",
      targetId: created.id,
      metadata: {
        kind: created.kind,
        startAt: created.startAt.toISOString(),
        endAt: created.endAt.toISOString(),
        note: created.note,
      },
    });

    return NextResponse.json(
      ok({
        override: {
          id: created.id,
          startAt: created.startAt.toISOString(),
          endAt: created.endAt.toISOString(),
          kind: created.kind,
          note: created.note,
        },
      })
    )
  } catch {
    return respondUnauthorized()
  }
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/availability/me/template/route.ts">
import { NextRequest, NextResponse } from "next/server"
import { z } from "zod"

import { prisma } from "@lattice/db"
import { fail, ok, ErrorCodes, logAudit, AuditActions } from "@lattice/shared"
import { requireOrgAccess } from "@/lib/guards"
import { normalizeIntervals } from "@/lib/availability/intervals"

export const runtime = "nodejs"

const WindowSchema = z
  .object({
    dayOfWeek: z.number().int().min(1).max(7),
    startMinute: z.number().int().min(0).max(1439),
    endMinute: z.number().int().min(1).max(1440),
  })
  .refine((w) => w.startMinute < w.endMinute, "startMinute must be < endMinute")

const BodySchema = z.object({
  timeZone: z.string().min(1).optional(),
  windows: z.array(WindowSchema).max(500),
})

/**
 * @openapi
 * /api/orgs/{orgId}/availability/me/template:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   get:
 *     summary: Retrieves the authenticated user's availability template for an organization.
 *     tags:
 *       - Availability
 *     responses:
 *       "200":
 *         description: Availability template and timezone.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     timeZone:
 *                       type: string
 *                     windows:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           dayOfWeek:
 *                             type: integer
 *                           startMinute:
 *                             type: integer
 *                           endMinute:
 *                             type: integer
 *       "401":
 *         description: Authentication required.
 *   put:
 *     summary: Stores a normalized availability template for the current user.
 *     tags:
 *       - Availability
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               timeZone:
 *                 type: string
 *               windows:
 *                 type: array
 *                 items:
 *                   type: object
 *                   properties:
 *                     dayOfWeek:
 *                       type: integer
 *                     startMinute:
 *                       type: integer
 *                     endMinute:
 *                       type: integer
 *             required:
 *               - windows
 *     responses:
 *       "200":
 *         description: Template saved.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     timeZone:
 *                       type: string
 *                     windows:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           dayOfWeek:
 *                             type: integer
 *                           startMinute:
 *                             type: integer
 *                           endMinute:
 *                             type: integer
 *       "400":
 *         description: Validation error.
 *       "401":
 *         description: Authentication required.
 */
function respondUnauthorized() {
  return NextResponse.json(
    fail(ErrorCodes.UNAUTHENTICATED, "unauthorized"),
    { status: 401 }
  )
}

export async function GET(_: NextRequest, { params }: { params: Promise<{ orgId: string }> }) {
  const { orgId } = await params

  try {
    const access = await requireOrgAccess(orgId, { notFoundOnFail: true })
    if (!access.ok) return access.response

    const userId = access.membership.userId

    const template = await prisma.availabilityTemplate.findUnique({
      where: { orgId_userId: { orgId, userId } },
      include: { windows: true },
    })

    const windows = (template?.windows ?? [])
      .map((w) => ({
        dayOfWeek: w.dayOfWeek,
        startMinute: w.startMinute,
        endMinute: w.endMinute,
      }))
      .sort((a, b) => a.dayOfWeek - b.dayOfWeek || a.startMinute - b.startMinute)

    return NextResponse.json(
      ok({
        timeZone: template?.timeZone ?? "UTC",
        windows,
      })
    )
  } catch {
    return respondUnauthorized()
  }
}

export async function PUT(req: NextRequest, { params }: { params: Promise<{ orgId: string }> }) {
  const { orgId } = await params

  let access
  try {
    access = await requireOrgAccess(orgId)
  } catch {
    return respondUnauthorized()
  }

  if (!access.ok) return access.response
  const userId = access.membership.userId

  const json = await req.json().catch(() => null)
  const parsed = BodySchema.safeParse(json)
  if (!parsed.success) {
    return NextResponse.json(
      fail(
        ErrorCodes.VALIDATION_ERROR,
        "Invalid body",
        parsed.error.flatten()
      ),
      { status: 400 }
    )
  }

  const timeZone = parsed.data.timeZone ?? "UTC"

  const byDay = new Map<number, { start: number; end: number }[]>()
  for (const w of parsed.data.windows) {
    const arr = byDay.get(w.dayOfWeek) ?? []
    arr.push({ start: w.startMinute, end: w.endMinute })
    byDay.set(w.dayOfWeek, arr)
  }

  const normalizedWindows = [...byDay.entries()].flatMap(([dayOfWeek, intervals]) => {
    return normalizeIntervals(intervals).map((i) => ({ dayOfWeek, startMinute: i.start, endMinute: i.end }))
  })

  const template = await prisma.availabilityTemplate.upsert({
    where: { orgId_userId: { orgId, userId } },
    create: {
      orgId,
      userId,
      timeZone,
      windows: { create: normalizedWindows },
    },
    update: {
      timeZone,
      windows: {
        deleteMany: {},
        create: normalizedWindows,
      },
    },
    include: { windows: true },
  })

  await logAudit({
    orgId,
    actorUserId: userId,
    action: AuditActions.AVAILABILITY_TEMPLATE_UPDATED,
    targetType: "AvailabilityTemplate",
    targetId: template.id,
    metadata: {
      timeZone: template.timeZone,
      windowCount: template.windows.length,
    },
  });

  const windows = template.windows
    .map((w) => ({
      dayOfWeek: w.dayOfWeek,
      startMinute: w.startMinute,
      endMinute: w.endMinute,
    }))
    .sort((a, b) => a.dayOfWeek - b.dayOfWeek || a.startMinute - b.startMinute)

  return NextResponse.json(
    ok({
      timeZone: template.timeZone,
      windows,
    })
  )
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/events/[eventId]/writeback/google/route.ts">
import { NextResponse } from "next/server";

import { prisma } from "@lattice/db";
import { env } from "@/lib/env";
import { fail, ok, ErrorCodes, logAudit, AuditActions } from "@lattice/shared";
import { requireOrgAccess } from "@/lib/guards";
import { createGoogleCalendarEvent } from "@/lib/google/calendar";

export const runtime = "nodejs";

/**
 * @openapi
 * /api/orgs/{orgId}/events/{eventId}/writeback/google:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *     - name: eventId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   post:
 *     summary: Triggers a Google Calendar write-back for a confirmed event.
 *     tags:
 *       - Events
 *     responses:
 *       "200":
 *         description: Write-back recorded and returns external event ID.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     externalEventId:
 *                       type: string
 *                       nullable: true
 *       "400":
 *         description: No active connection.
 *       "401":
 *         description: Authentication required.
 *       "404":
 *         description: Feature disabled or event not found.
 *       "500":
 *         description: Write-back failed.
 */
export async function POST(
  _req: Request,
  ctx: { params: Promise<{ orgId: string; eventId: string }> }
) {
  const { orgId, eventId } = await ctx.params;

  if (!env.EVENTS_ENABLED || !env.GCAL_WRITEBACK_ENABLED) {
    return NextResponse.json(
      fail(ErrorCodes.FEATURE_DISABLED, "disabled"),
      { status: 404 }
    );
  }

  const access = await requireOrgAccess(orgId);
  if (!access.ok) return access.response;
  const userId = access.membership.userId;

  const event = await prisma.scheduledEvent.findFirst({
    where: { id: eventId, orgId },
    include: { attendees: { include: { user: { select: { id: true, name: true, email: true } } } } },
  });
  if (!event) {
    return NextResponse.json(
      fail(ErrorCodes.NOT_FOUND, "not_found"),
      { status: 404 }
    );
  }

  const conn = await prisma.calendarConnection.findFirst({
    where: { userId, provider: "GOOGLE", status: "ACTIVE" },
  });
  if (!conn) {
    return NextResponse.json(
      fail(ErrorCodes.NO_CONNECTION, "no_connection"),
      { status: 400 }
    );
  }

  await prisma.scheduledEvent.update({
    where: { id: event.id },
    data: { writeBackStatus: "PENDING", externalProvider: "google", externalCalendarId: "primary" },
  });

  try {
    if (
      !conn.scopes?.includes("calendar.events") &&
      !conn.scopes?.includes("https://www.googleapis.com/auth/calendar.events")
    ) {
      throw new Error("Missing write scope. Reconnect Google Calendar with write-back enabled.");
    }

    const attendees = event.attendees
      .map((a) => a.user.email)
      .filter((email): email is string => Boolean(email))
      .map((email) => ({ email }));

    const created = await createGoogleCalendarEvent({
      refreshTokenCiphertext: conn.encryptedRefreshToken,
      calendarId: "primary",
      summary: event.title,
      description: event.notes ?? undefined,
      startISO: event.startUtc.toISOString(),
      endISO: event.endUtc.toISOString(),
      timeZone: event.timeZone,
      attendees,
      sendUpdates: "all",
    });

      await prisma.scheduledEvent.update({
        where: { id: event.id },
        data: {
          writeBackStatus: "SUCCESS",
          externalEventId: created.id ?? null,
          externalEventHtmlLink: created.htmlLink ?? null,
          writeBackError: null,
        },
      });

    await logAudit({
      orgId,
      actorUserId: userId,
      action: AuditActions.WRITEBACK_ATTEMPTED,
      targetType: "ScheduledEvent",
      targetId: event.id,
      metadata: {
        source: "events.writeback",
        success: true,
      },
    });

    return NextResponse.json(ok({ externalEventId: created.id ?? null }));
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error);
    await prisma.scheduledEvent.update({
      where: { id: event.id },
      data: { writeBackStatus: "ERROR", writeBackError: message },
    });

    await logAudit({
      orgId,
      actorUserId: userId,
      action: AuditActions.WRITEBACK_ATTEMPTED,
      targetType: "ScheduledEvent",
      targetId: event.id,
      metadata: {
        source: "events.writeback",
        success: false,
        error: message,
      },
    });
    return NextResponse.json(
      fail(ErrorCodes.SYNC_FAILED, message),
      { status: 500 }
    );
  }
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/integrations/google/calendars/route.ts">
import { NextResponse } from "next/server";
import { prisma } from "@lattice/db";
import { ok, logAudit, AuditActions } from "@lattice/shared";
import { requireOrgAccess } from "@/lib/guards";
import { listCalendars, calendarIdHash } from "@/lib/google/calendar";

export const runtime = "nodejs";

/**
 * @openapi
 * /api/orgs/{orgId}/integrations/google/calendars:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   get:
 *     summary: Returns Google Calendar metadata and selection markers.
 *     tags:
 *       - Integrations
 *     responses:
 *       "200":
 *         description: Calendar connection status and metadata.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     connected:
 *                       type: boolean
 *                     lastSyncAt:
 *                       type: string
 *                       format: date-time
 *                     calendars:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           idHash:
 *                             type: string
 *                           summary:
 *                             type: string
 *                           primary:
 *                             type: boolean
 *                           accessRole:
 *                             type: string
 *                           isBusySource:
 *                             type: boolean
 */
export async function GET(_: Request, { params }: { params: Promise<{ orgId: string }> }) {
  const { orgId } = await params;
  const access = await requireOrgAccess(orgId);
  if (!access.ok) return access.response;

  const userId = access.membership.userId;
  const conn = await prisma.calendarConnection.findUnique({
    where: { userId_provider: { userId, provider: "GOOGLE" } },
    select: { id: true, status: true, lastSyncAt: true, encryptedRefreshToken: true },
  });
  if (!conn || conn.status !== "ACTIVE") {
    return NextResponse.json(ok({ connected: false, calendars: [] }));
  }

  const selected = await prisma.calendarSelection.findMany({
    where: { connectionId: conn.id, orgId, isBusySource: true },
    select: { calendarIdHash: true },
  });
  const set = new Set(selected.map((s) => s.calendarIdHash));

  const calendars = await listCalendars(conn.encryptedRefreshToken);

  return NextResponse.json(
    ok({
      connected: true,
      lastSyncAt: conn.lastSyncAt,
      calendars: calendars.map((c) => {
        const idHash = calendarIdHash(c.id);
        return {
          idHash,
          summary: c.summary ?? "(untitled)",
          primary: !!c.primary,
          accessRole: c.accessRole ?? "unknown",
          isBusySource: set.has(idHash),
        };
      }),
    })
  );
}

export async function DELETE(_: Request, { params }: { params: Promise<{ orgId: string }> }) {
  const { orgId } = await params;
  const access = await requireOrgAccess(orgId);
  if (!access.ok) return access.response;

  const userId = access.membership.userId;

  const conn = await prisma.calendarConnection.findUnique({
    where: { userId_provider: { userId, provider: "GOOGLE" } },
    select: { id: true },
  });
  if (!conn) {
    return NextResponse.json(ok({}));
  }

  await prisma.busyBlock.deleteMany({
    where: { orgId, userId, provider: "GOOGLE" },
  });

  await prisma.calendarConnection.delete({ where: { id: conn.id } });

  await logAudit({
    orgId,
    actorUserId: userId,
    action: AuditActions.CALENDAR_DISCONNECTED,
    targetType: "CalendarConnection",
    targetId: conn.id,
    metadata: {
      provider: "GOOGLE",
    },
  });

  return NextResponse.json(ok({}));
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/integrations/google/selections/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";
import { prisma } from "@lattice/db";
import { fail, ok, ErrorCodes } from "@lattice/shared";
import { requireOrgAccess } from "@/lib/guards";

export const runtime = "nodejs";

const Body = z.object({ busyCalendarIdHashes: z.array(z.string().min(32)).default([]) });

/**
 * @openapi
 * /api/orgs/{orgId}/integrations/google/selections:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   put:
 *     summary: Sets the list of calendars that should be treated as busy sources.
 *     tags:
 *       - Integrations
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               busyCalendarIdHashes:
 *                 type: array
 *                 items:
 *                   type: string
 *             required:
 *               - busyCalendarIdHashes
 *     responses:
 *       "200":
 *         description: Calendar selections updated.
 *       "400":
 *         description: Validation failure or not connected.
 *       "401":
 *         description: Authentication required.
 */
export async function PUT(req: Request, { params }: { params: Promise<{ orgId: string }> }) {
  const { orgId } = await params;
  const access = await requireOrgAccess(orgId);
  if (!access.ok) return access.response;

  const userId = access.membership.userId;
  const body = Body.parse(await req.json());

  const conn = await prisma.calendarConnection.findUnique({
    where: { userId_provider: { userId, provider: "GOOGLE" } },
    select: { id: true, status: true },
  });
  if (!conn || conn.status !== "ACTIVE") {
    return NextResponse.json(
      fail(ErrorCodes.NOT_CONNECTED, "not_connected"),
      { status: 400 }
    );
  }

  const desired = new Set(body.busyCalendarIdHashes);

  await prisma.$transaction(async (tx) => {
    await tx.calendarSelection.deleteMany({ where: { connectionId: conn.id, orgId } });
    if (desired.size) {
      await tx.calendarSelection.createMany({
        data: [...desired].map((calendarIdHash) => ({
          connectionId: conn.id,
          orgId,
          calendarIdHash,
          isBusySource: true,
        })),
      });
    }
  });

  return NextResponse.json(ok({}));
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/integrations/google/start/route.ts">
import { NextResponse } from "next/server";
import crypto from "crypto";
import { google } from "googleapis";

import { env } from "@/lib/env";
import { requireOrgAccess } from "@/lib/guards";
import { setOauthCookie, createPkcePair } from "@/lib/google/oauth";
import { getGcalScopes } from "@/lib/google/calendar";

export const runtime = "nodejs";

/**
 * @openapi
 * /api/orgs/{orgId}/integrations/google/start:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   get:
 *     summary: Starts the Google Calendar OAuth flow for an organization.
 *     tags:
 *       - Integrations
 *     responses:
 *       "302":
 *         description: Redirects the browser to Google's consent screen.
 *       "401":
 *         description: Unauthorized.
 */
export async function GET(_: Request, { params }: { params: Promise<{ orgId: string }> }) {
  const { orgId } = await params;
  const access = await requireOrgAccess(orgId);
  if (!access.ok) return access.response;

  const state = crypto.randomBytes(24).toString("base64url");
  const { verifier, challenge } = createPkcePair();

  await setOauthCookie({
    state,
    verifier,
    orgId,
    userId: access.membership.userId,
    createdAt: Date.now(),
  });

  const scope = getGcalScopes().join(" ");

  const oauth2 = new google.auth.OAuth2(env.GCAL_CLIENT_ID, env.GCAL_CLIENT_SECRET, env.GCAL_REDIRECT_URI);

  const url = oauth2.generateAuthUrl({
    access_type: "offline",
    include_granted_scopes: true,
    scope,
    prompt: "consent",
    state,
    code_challenge: challenge,
    code_challenge_method: "S256",
  });

  return NextResponse.redirect(url);
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/integrations/google/sync/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";
import { DateTime } from "luxon";

import { prisma } from "@lattice/db";
import {
  fail,
  ok,
  ErrorCodes,
  logAudit,
  AuditActions,
  buildRateLimitKey,
  buildRetryAfterHeader,
  enforceRateLimit,
} from "@lattice/shared";
import { requireOrgAccess } from "@/lib/guards";
import {
  listCalendars,
  freeBusy,
  calendarIdHash,
  mergeUtcIntervals,
  MERGED_SOURCE_HASH,
  blockHash,
} from "@/lib/google/calendar";
import {
  getIdempotencyResponse,
  saveIdempotencyResponse,
  computeIdempotencyHash,
} from "@/lib/idempotency";

export const runtime = "nodejs";

const Body = z.object({
  rangeStart: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  rangeEnd: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  timeZone: z.string().min(1).optional(),
});

/**
 * @openapi
 * /api/orgs/{orgId}/integrations/google/sync:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   post:
 *     summary: Fetches busy intervals from Google Calendar and records busy blocks.
 *     tags:
 *       - Integrations
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               rangeStart:
 *                 type: string
 *                 format: date
 *               rangeEnd:
 *                 type: string
 *                 format: date
 *               timeZone:
 *                 type: string
 *     responses:
 *       "200":
 *         description: Blocks synced.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     blocks:
 *                       type: integer
 *       "400":
 *         description: Validation failure or missing connection/selection.
 *       "500":
 *         description: Sync attempt failed.
 */
export async function POST(req: Request, { params }: { params: Promise<{ orgId: string }> }) {
  const { orgId } = await params;
  const access = await requireOrgAccess(orgId);
  if (!access.ok) return access.response;

  const userId = access.membership.userId;
  const syncLimit = await enforceRateLimit(
    "sync",
    buildRateLimitKey("sync", [userId])
  );
  if (!syncLimit.allowed) {
    return NextResponse.json(syncLimit.response, {
      status: 429,
      headers: buildRetryAfterHeader(syncLimit.retryAfterSeconds),
    });
  }
  const body = Body.parse(await req.json());
  const idempotencyKeyHeader = req.headers.get("Idempotency-Key");
  const requestHash = computeIdempotencyHash({ params: { orgId }, body });

  const idempotencyResponse = await getIdempotencyResponse({
    orgId,
    endpoint: "integrations.google.sync",
    key: idempotencyKeyHeader,
    requestHash,
  });

  if (idempotencyResponse.type === "response") {
    return NextResponse.json(idempotencyResponse.response.body, {
      status: idempotencyResponse.response.status,
    });
  }

  if (idempotencyResponse.type === "conflict") {
    return NextResponse.json(
      fail(ErrorCodes.IDEMPOTENCY_CONFLICT, "idempotency_conflict"),
      { status: 409 },
    );
  }

  if (idempotencyResponse.type === "incomplete") {
    return NextResponse.json(
      fail(ErrorCodes.RATE_LIMITED, "idempotency_in_progress"),
      { status: 429 },
    );
  }

  const tz = body.timeZone ?? "UTC";

  const start = DateTime.fromISO(body.rangeStart ?? DateTime.utc().toISODate()!, { zone: tz }).startOf("day").toUTC();
  const end = DateTime.fromISO(body.rangeEnd ?? DateTime.utc().plus({ days: 30 }).toISODate()!, { zone: tz }).endOf("day").toUTC();

  const conn = await prisma.calendarConnection.findUnique({
    where: { userId_provider: { userId, provider: "GOOGLE" } },
    select: { id: true, encryptedRefreshToken: true, status: true },
  });
  if (!conn || conn.status !== "ACTIVE") {
    return NextResponse.json(
      fail(ErrorCodes.NOT_CONNECTED, "not_connected"),
      { status: 400 }
    );
  }

  const selections = await prisma.calendarSelection.findMany({
    where: { connectionId: conn.id, orgId, isBusySource: true },
    select: { calendarIdHash: true },
  });
  const selectedHashes = new Set(selections.map((s) => s.calendarIdHash));
  if (!selectedHashes.size) {
    return NextResponse.json(
      fail(ErrorCodes.NO_CALENDARS_SELECTED, "no_calendars_selected"),
      { status: 400 }
    );
  }

  const run = await prisma.calendarSyncRun.create({
    data: {
      orgId,
      userId,
      connectionId: conn.id,
      provider: "GOOGLE",
      rangeStartUtc: start.toJSDate(),
      rangeEndUtc: end.toJSDate(),
      status: "STARTED",
    },
    select: { id: true },
  });

  await logAudit({
    orgId,
    actorUserId: userId,
    action: AuditActions.CALENDAR_SYNC_STARTED,
    targetType: "CalendarSyncRun",
    targetId: run.id,
    metadata: {
      rangeStart: start.toISOString(),
      rangeEnd: end.toISOString(),
      timeZone: tz,
    },
  });

  try {
    const calendars = await listCalendars(conn.encryptedRefreshToken);
    const busyIds = calendars.filter((c) => selectedHashes.has(calendarIdHash(c.id))).map((c) => c.id);
    if (!busyIds.length) throw new Error("selected_calendars_not_found");

    const fb = await freeBusy({
      refreshTokenCiphertext: conn.encryptedRefreshToken,
      calendarIds: busyIds,
      timeMinISO: start.toISO(),
      timeMaxISO: end.toISO(),
      timeZone: tz,
    });

    const intervals: Array<{ startUtc: Date; endUtc: Date }> = [];
    for (const calId of busyIds) {
      const busy = fb[calId]?.busy ?? [];
      for (const b of busy) {
        if (!b.start || !b.end) continue;
        intervals.push({ startUtc: new Date(b.start), endUtc: new Date(b.end) });
      }
    }

    const merged = mergeUtcIntervals(intervals);

    await prisma.$transaction(async (tx) => {
      await tx.busyBlock.deleteMany({
        where: {
          orgId,
          userId,
          provider: "GOOGLE",
          startUtc: { lt: end.toJSDate() },
          endUtc: { gt: start.toJSDate() },
        },
      });

      if (merged.length) {
        await tx.busyBlock.createMany({
          data: merged.map((m) => {
            const startISO = m.startUtc.toISOString();
            const endISO = m.endUtc.toISOString();
            return {
              orgId,
              userId,
              provider: "GOOGLE",
              sourceHash: MERGED_SOURCE_HASH,
              startUtc: m.startUtc,
              endUtc: m.endUtc,
              blockHash: blockHash({
                orgId,
                userId,
                sourceHash: MERGED_SOURCE_HASH,
                startISO,
                endISO,
              }),
            };
          }),
          skipDuplicates: true,
        });
      }

      await tx.calendarConnection.update({ where: { id: conn.id }, data: { lastSyncAt: new Date() } });
      await tx.calendarSyncRun.update({ where: { id: run.id }, data: { status: "SUCCESS", finishedAt: new Date() } });
    });

    const payload = ok({ blocks: merged.length });

    await logAudit({
      orgId,
      actorUserId: userId,
      action: AuditActions.CALENDAR_SYNC_SUCCESS,
      targetType: "CalendarSyncRun",
      targetId: run.id,
      metadata: {
        mergedBlocks: merged.length,
      },
    });
    try {
      await saveIdempotencyResponse({
        orgId,
        endpoint: "integrations.google.sync",
        key: idempotencyKeyHeader,
        requestHash,
        responseStatus: 200,
        responseBody: payload,
      });
    } catch (error) {
      console.warn("[idempotency] failed to persist sync response", error);
    }

    return NextResponse.json(payload);
  } catch (error: unknown) {
    const detail = error instanceof Error ? error.message : String(error);
    await prisma.calendarSyncRun.update({
      where: { id: run.id },
      data: {
        status: "ERROR",
        errorCode: "SYNC_FAILED",
        errorDetail: detail,
        finishedAt: new Date(),
      },
    });

    await logAudit({
      orgId,
      actorUserId: userId,
      action: AuditActions.CALENDAR_SYNC_FAILURE,
      targetType: "CalendarSyncRun",
      targetId: run.id,
      metadata: {
        error: detail,
      },
    });
    return NextResponse.json(
      fail(ErrorCodes.SYNC_FAILED, "sync_failed", detail),
      { status: 500 }
    );
  }
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/members/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";

import { prisma } from "@lattice/db";
import {
  fail,
  ok,
  ErrorCodes,
  logAudit,
  AuditActions,
  buildRateLimitKey,
  buildRetryAfterHeader,
  enforceRateLimit,
} from "@lattice/shared";
import { requireOrgAccess } from "@/lib/guards";

export const runtime = "nodejs";

const AddMemberSchema = z.object({
  email: z.string().email(),
  role: z.enum(["MEMBER", "LEADER", "ADMIN"]).default("MEMBER"),
});

/**
 * @openapi
 * /api/orgs/{orgId}/members:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   get:
 *     summary: Lists the members of an organization.
 *     tags:
 *       - Members
 *     responses:
 *       "200":
 *         description: Membership roster.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     members:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           id:
 *                             type: string
 *                           role:
 *                             type: string
 *                           createdAt:
 *                             type: string
 *                             format: date-time
 *                           user:
 *                             type: object
 *                             properties:
 *                               id:
 *                                 type: string
 *                               email:
 *                                 type: string
 *                               name:
 *                                 type: string
 *                               image:
 *                                 type: string
 *       "401":
 *         description: Authentication required.
 *   post:
 *     summary: Invites or adds a member by email.
 *     tags:
 *       - Members
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               role:
 *                 type: string
 *                 enum:
 *                   - MEMBER
 *                   - LEADER
 *                   - ADMIN
 *             required:
 *               - email
 *     responses:
 *       "201":
 *         description: Member created.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     membership:
 *                       type: object
 *                       properties:
 *                         id:
 *                           type: string
 *                         role:
 *                           type: string
 *       "400":
 *         description: Validation or user not found error.
 *       "401":
 *         description: Authentication required.
 */
export async function GET(
  _req: Request,
  ctx: { params: Promise<{ orgId: string }> }
) {
  const { orgId } = await ctx.params;

  const access = await requireOrgAccess(orgId, { notFoundOnFail: true });
  if (!access.ok) return access.response;

  const members = await prisma.membership.findMany({
    where: { orgId },
    orderBy: { createdAt: "asc" },
    select: {
      userId: true,
      id: true,
      role: true,
      createdAt: true,
      user: { select: { id: true, email: true, name: true, image: true } },
    },
  });

  return NextResponse.json(ok({ members }));
}

export async function POST(
  req: Request,
  ctx: { params: Promise<{ orgId: string }> }
) {
  const { orgId } = await ctx.params;

  const access = await requireOrgAccess(orgId, {
    minRole: "ADMIN",
    notFoundOnFail: true,
  });
  if (!access.ok) return access.response;

  const membershipLimit = await enforceRateLimit(
    "membership",
    buildRateLimitKey("membership", [orgId, access.membership.userId])
  );
  if (!membershipLimit.allowed) {
    return NextResponse.json(
      membershipLimit.response,
      {
        status: 429,
        headers: buildRetryAfterHeader(membershipLimit.retryAfterSeconds),
      }
    );
  }

  const body = await req.json().catch(() => null);
  const parsed = AddMemberSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      fail(
        ErrorCodes.VALIDATION_ERROR,
        "invalid_input",
        parsed.error.flatten()
      ),
      { status: 400 }
    );
  }

  const email = parsed.data.email.toLowerCase().trim();

  const user = await prisma.user.findUnique({
    where: { email },
    select: { id: true },
  });

  if (!user) {
    return NextResponse.json(
      fail(ErrorCodes.USER_NOT_FOUND, "user_not_found"),
      { status: 400 }
    );
  }

  const membership = await prisma.membership.create({
    data: {
      orgId,
      userId: user.id,
      role: parsed.data.role,
    },
    select: { id: true, role: true },
  });

  await logAudit({
    orgId,
    actorUserId: access.membership.userId,
    action: AuditActions.MEMBER_INVITED,
    targetType: "Membership",
    targetId: membership.id,
    metadata: {
      userId: user.id,
      email,
      role: membership.role,
    },
  });

  return NextResponse.json(ok({ membership }), { status: 201 });
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/suggestions/requests/[requestId]/confirm/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";

import { prisma } from "@lattice/db";
import { fail, ok, ErrorCodes, logAudit, AuditActions } from "@lattice/shared";
import { env } from "@/lib/env";
import { requireOrgAccess } from "@/lib/guards";
import { createGoogleCalendarEvent } from "@/lib/google/calendar";
import { findConflictingUserIds } from "@/lib/events/conflicts";
import {
  getIdempotencyResponse,
  saveIdempotencyResponse,
  computeIdempotencyHash,
} from "@/lib/idempotency";
import { loadSuggestionAvailabilityState } from "@/lib/suggestions/state";

export const runtime = "nodejs";

const Body = z.object({
  candidateRank: z.number().int().positive(),
  title: z.string().min(1).max(140).optional(),
  notes: z.string().max(2000).optional(),
  writeBackToGoogle: z.boolean().optional().default(false),
  conflictCheck: z.boolean().optional().default(true),
});

async function requireLeader(orgId: string) {
  return requireOrgAccess(orgId, { minRole: "LEADER" });
}

/**
 * @openapi
 * /api/orgs/{orgId}/suggestions/requests/{requestId}/confirm:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *     - name: requestId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   post:
 *     summary: Confirms a suggestion candidate and persists the scheduled event.
 *     tags:
 *       - Suggestions
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               candidateRank:
 *                 type: integer
 *               title:
 *                 type: string
 *               notes:
 *                 type: string
 *               writeBackToGoogle:
 *                 type: boolean
 *               conflictCheck:
 *                 type: boolean
 *             required:
 *               - candidateRank
 *     responses:
 *       "200":
 *         description: Event created or retrieved with attendees.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     event:
 *                       type: object
 *       "400":
 *         description: Validation error, invalid rank, or missing scopes.
 *       "401":
 *         description: Authentication required.
 *       "404":
 *         description: Feature disabled or request not found.
 *       "409":
 *         description: Conflict detected with busy intervals.
 */
export async function POST(req: Request, ctx: { params: Promise<{ orgId: string; requestId: string }> }) {
  const { orgId, requestId } = await ctx.params;

  if (!env.SUGGESTIONS_ENABLED || !env.EVENTS_ENABLED) {
    return NextResponse.json(
      fail(ErrorCodes.FEATURE_DISABLED, "disabled"),
      { status: 404 }
    );
  }

  const access = await requireLeader(orgId);
  if (!access.ok) return access.response;
  const userId = access.membership.userId;

  const body = Body.parse(await req.json());
  const idempotencyKeyHeader = req.headers.get("Idempotency-Key");
  const requestHash = computeIdempotencyHash({ params: { orgId, requestId }, body });

  const idempotencyResponse = await getIdempotencyResponse({
    orgId,
    endpoint: "suggestions.confirm",
    key: idempotencyKeyHeader,
    requestHash,
  });

  if (idempotencyResponse.type === "response") {
    return NextResponse.json(idempotencyResponse.response.body, {
      status: idempotencyResponse.response.status,
    });
  }

  if (idempotencyResponse.type === "conflict") {
    return NextResponse.json(
      fail(ErrorCodes.IDEMPOTENCY_CONFLICT, "idempotency_conflict"),
      { status: 409 },
    );
  }

  if (idempotencyResponse.type === "incomplete") {
    return NextResponse.json(
      fail(ErrorCodes.RATE_LIMITED, "idempotency_in_progress"),
      { status: 429 },
    );
  }

  const requestRow = await prisma.suggestionRequest.findFirst({
    where: { id: requestId, orgId },
    include: {
      candidates: { where: { rank: body.candidateRank }, take: 1 },
      attendees: { include: { user: { select: { id: true, email: true, name: true } } } },
    },
  });

  if (!requestRow) {
    return NextResponse.json(
      fail(ErrorCodes.NOT_FOUND, "not_found"),
      { status: 404 }
    );
  }

  const candidate = requestRow.candidates[0];
  if (!candidate) {
    return NextResponse.json(
      fail(ErrorCodes.BAD_CANDIDATE_RANK, "bad_candidate_rank"),
      { status: 400 }
    );
  }

  const startUtc = candidate.startAt;
  const endUtc = candidate.endAt;
  const attendeeUserIds = requestRow.attendees.map((a) => a.userId);

  const availabilityState = await loadSuggestionAvailabilityState({
    orgId,
    attendeeUserIds,
    rangeStart: requestRow.rangeStart,
    rangeEnd: requestRow.rangeEnd,
  });

  if (
    requestRow.dataFingerprint &&
    requestRow.dataFingerprint !== availabilityState.dataFingerprint
  ) {
    return NextResponse.json(
      fail(ErrorCodes.CONFLICT, "conflict_detected", {
        previousFingerprint: requestRow.dataFingerprint,
        currentFingerprint: availabilityState.dataFingerprint,
      }),
      { status: 409 },
    );
  }

  if (body.conflictCheck && attendeeUserIds.length) {
    const busyConflicts = availabilityState.busyBlocks.filter((block) =>
      intervalsOverlap(startUtc, endUtc, block.startUtc, block.endUtc),
    );
    const overrideConflicts = availabilityState.overrides.filter(
      (override) =>
        override.kind === "UNAVAILABLE" &&
        intervalsOverlap(startUtc, endUtc, override.startAt, override.endAt),
    );

    const conflictUserIds = findConflictingUserIds({
      intervalStart: startUtc,
      intervalEnd: endUtc,
      intervals: [
        ...busyConflicts.map((block) => ({ userId: block.userId, start: block.startUtc, end: block.endUtc })),
        ...overrideConflicts.map((override) => ({ userId: override.userId, start: override.startAt, end: override.endAt })),
      ],
    });

    await logAudit({
      orgId,
      actorUserId: userId,
      action: AuditActions.ACCEPTANCE_CHECK,
      targetType: "SuggestionRequest",
      targetId: requestRow.id,
      metadata: {
        candidateRank: body.candidateRank,
        conflictDetected: conflictUserIds.length > 0,
        conflictUserIds,
      },
    });

    if (conflictUserIds.length) {
      return NextResponse.json(
        fail(ErrorCodes.CONFLICT, "conflict", { conflictUserIds }),
        { status: 409 },
      );
    }
  }

  const event = await prisma.$transaction(async (tx) => {
    const existing = await tx.scheduledEvent.findFirst({
      where: { sourceRequestId: requestId, sourceCandidateRank: body.candidateRank },
      include: { attendees: { include: { user: { select: { id: true, email: true, name: true } } } } },
    });
    if (existing) return existing;

    const created = await tx.scheduledEvent.create({
      data: {
        orgId,
        title: body.title ?? requestRow.title ?? "Scheduled event",
        notes: body.notes ?? null,
        startUtc,
        endUtc,
        timeZone: requestRow.timeZone,
        sourceRequestId: requestId,
        sourceCandidateRank: body.candidateRank,
        createdById: userId,
        confirmedById: userId,
      },
    });

    await tx.scheduledEventAttendee.createMany({
      data: attendeeUserIds.map((attendeeId) => ({
        eventId: created.id,
        userId: attendeeId,
        rsvp: attendeeId === userId ? "ACCEPTED" : "INVITED",
      })),
      skipDuplicates: true,
    });

    return tx.scheduledEvent.findUniqueOrThrow({
      where: { id: created.id },
      include: { attendees: { include: { user: { select: { id: true, email: true, name: true } } } } },
    });
  });

  if (body.writeBackToGoogle && env.GCAL_WRITEBACK_ENABLED) {
    try {
      await prisma.scheduledEvent.update({
        where: { id: event.id },
        data: { writeBackStatus: "PENDING", externalProvider: "google", externalCalendarId: "primary" },
      });

      const conn = await prisma.calendarConnection.findFirst({
        where: { userId, provider: "GOOGLE", status: "ACTIVE" },
      });
      if (!conn) throw new Error("No active Google Calendar connection for this user");

      if (
        !conn.scopes?.includes("calendar.events") &&
        !conn.scopes?.includes("https://www.googleapis.com/auth/calendar.events")
      ) {
        throw new Error("Missing write scope. Reconnect Google Calendar with write-back enabled.");
      }

      const attendees = event.attendees
        .map((a) => a.user.email)
        .filter((email): email is string => Boolean(email))
        .map((email) => ({ email }));

      const created = await createGoogleCalendarEvent({
        refreshTokenCiphertext: conn.encryptedRefreshToken,
        calendarId: "primary",
        summary: event.title,
        description: event.notes ?? undefined,
        startISO: event.startUtc.toISOString(),
        endISO: event.endUtc.toISOString(),
        timeZone: event.timeZone,
        attendees,
        sendUpdates: "all",
      });

      await prisma.scheduledEvent.update({
        where: { id: event.id },
        data: {
          writeBackStatus: "SUCCESS",
          externalEventId: created.id ?? null,
          externalEventHtmlLink: created.htmlLink ?? null,
          writeBackError: null,
        },
      });

      await logAudit({
        orgId,
        actorUserId: userId,
        action: AuditActions.WRITEBACK_ATTEMPTED,
        targetType: "ScheduledEvent",
        targetId: event.id,
        metadata: {
          source: "suggestions.confirm",
          success: true,
        },
      });
    } catch (error: unknown) {
      const message = error instanceof Error ? error.message : String(error);
      await prisma.scheduledEvent.update({
        where: { id: event.id },
        data: { writeBackStatus: "ERROR", writeBackError: message },
      });

      await logAudit({
        orgId,
        actorUserId: userId,
        action: AuditActions.WRITEBACK_ATTEMPTED,
        targetType: "ScheduledEvent",
        targetId: event.id,
        metadata: {
          source: "suggestions.confirm",
          success: false,
          error: message,
        },
      });
    }
  }

  const refreshed = await prisma.scheduledEvent.findUnique({
    where: { id: event.id },
    include: { attendees: { include: { user: { select: { id: true, email: true, name: true } } } } },
  });

  await logAudit({
    orgId,
    actorUserId: userId,
    action: AuditActions.SLOT_CONFIRMED,
    targetType: "ScheduledEvent",
    targetId: refreshed?.id ?? event.id,
    metadata: {
      requestId,
      candidateRank: body.candidateRank,
      startUtc: event.startUtc.toISOString(),
      endUtc: event.endUtc.toISOString(),
    },
  });

  const payload = ok({ event: refreshed });
  try {
    await saveIdempotencyResponse({
      orgId,
      endpoint: "suggestions.confirm",
      key: idempotencyKeyHeader,
      requestHash,
      responseStatus: 200,
      responseBody: payload,
    });
  } catch (error) {
    console.warn("[idempotency] failed to persist confirm response", error);
  }

  return NextResponse.json(payload);
}

function intervalsOverlap(aStart: Date, aEnd: Date, bStart: Date, bEnd: Date) {
  return bStart < aEnd && bEnd > aStart;
}
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/suggestions/requests/[requestId]/route.ts">
import { NextResponse } from "next/server"

import { prisma } from "@lattice/db"
import { fail, ok, ErrorCodes } from "@lattice/shared"
import { requireOrgAccess } from "@/lib/guards"
import { env } from "@/lib/env"

export const runtime = "nodejs"

/**
 * @openapi
 * /api/orgs/{orgId}/suggestions/requests/{requestId}:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *     - name: requestId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   get:
 *     summary: Retrieves a single suggestion request with candidates.
 *     tags:
 *       - Suggestions
 *     responses:
 *       "200":
 *         description: Suggestion request and candidate metadata.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     request:
 *                       type: object
 *       "401":
 *         description: Authentication required.
 *       "404":
 *         description: Request not found or feature disabled.
 */
export async function GET(_req: Request, { params }: { params: Promise<{ orgId: string; requestId: string }> }) {
  if (!env.SUGGESTIONS_ENABLED) {
    return NextResponse.json(
      fail(ErrorCodes.NOT_FOUND, "Not found"),
      { status: 404 }
    )
  }

  const { orgId, requestId } = await params;
  const access = await requireOrgAccess(orgId, { minRole: "LEADER" })
  if (!access.ok) return access.response

  const request = await prisma.suggestionRequest.findUnique({
    where: { id: requestId },
    include: {
      attendees: true,
      candidates: { orderBy: { rank: "asc" } },
    },
  })

  if (!request || request.orgId !== orgId) {
    return NextResponse.json(
      fail(ErrorCodes.NOT_FOUND, "Not found"),
      { status: 404 }
    )
  }

  return NextResponse.json(ok({ request }))
}
</file>

<file path="apps/web/src/features/suggestions/SuggestionsClient.tsx">
"use client"

import { useEffect, useId, useMemo, useState } from "react"
import { useRouter } from "next/navigation"
import { DateTime } from "luxon"
import { toast } from "sonner"

import { ApiError, fetchJson } from "@/lib/http"

import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Input } from "@/components/ui/input"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"

type Member = {
  userId: string
  user: { name: string | null; email: string | null }
  role: string
}

type Candidate = {
  rank: number
  startAt: string
  endAt: string
  attendanceRatio: number
  score: { total: number; attendance: number; inconvenience: number; fairness: number }
  availableUserIds: string[]
  missingUserIds: string[]
  explanation: { why: string[] }
}

export default function SuggestionsClient({ orgId, orgName }: { orgId: string; orgName: string }) {
  const [members, setMembers] = useState<Member[]>([])
  const [selected, setSelected] = useState<string[]>([])

  const [timeZone, setTimeZone] = useState<string>(
    () => Intl.DateTimeFormat().resolvedOptions().timeZone ?? "UTC",
  )
  const [rangeStart, setRangeStart] = useState<string>(() => DateTime.now().toISODate() ?? "")
  const [rangeEnd, setRangeEnd] = useState<string>(() => DateTime.now().plus({ days: 7 }).toISODate() ?? "")
  const [durationMinutes, setDurationMinutes] = useState<number>(30)
  const [stepMinutes, setStepMinutes] = useState<number>(15)
  const [dayStart, setDayStart] = useState<string>("08:00")
  const [dayEnd, setDayEnd] = useState<string>("20:00")
  const [title, setTitle] = useState<string>("")

  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [candidates, setCandidates] = useState<Candidate[]>([])
  const router = useRouter()
  const [requestId, setRequestId] = useState<string | null>(null)
  const [confirmingRank, setConfirmingRank] = useState<number | null>(null)
  const [confirmError, setConfirmError] = useState<string | null>(null)
  const [writeBack, setWriteBack] = useState(false)
  const baseId = useId()
  const fieldIds = {
    title: `${baseId}-title`,
    timeZone: `${baseId}-timezone`,
    rangeStart: `${baseId}-range-start`,
    rangeEnd: `${baseId}-range-end`,
    dayStart: `${baseId}-day-start`,
    dayEnd: `${baseId}-day-end`,
  }

  const memberById = useMemo(() => {
    const map = new Map<string, Member>()
    for (const member of members) {
      map.set(member.userId, member)
    }
    return map
  }, [members])

  useEffect(() => {
    void (async () => {
      try {
        const data = await fetchJson<{ members?: Member[] }>(`/api/orgs/${orgId}/members`)
        const fetched = Array.isArray(data.members) ? data.members : []
        setMembers(fetched)
        setSelected(fetched.slice(0, 2).map((member) => member.userId))
      } catch {
        setMembers([])
        setSelected([])
      }
    })()
  }, [orgId])

  function toggleUser(userId: string) {
    setSelected((prev) =>
      prev.includes(userId) ? prev.filter((id) => id !== userId) : [...prev, userId],
    )
  }

  async function onSubmit(event: React.FormEvent) {
    event.preventDefault()
    setLoading(true)
    setError(null)
    setCandidates([])
    setRequestId(null)
    setConfirmError(null)
    setConfirmingRank(null)

    try {
      const data = await fetchJson<{ request?: { id?: string }; candidates?: Candidate[] }>(
        `/api/orgs/${orgId}/suggestions/requests`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            title: title || undefined,
            timeZone,
            rangeStart,
            rangeEnd,
            durationMinutes,
            stepMinutes,
            dayStart,
            dayEnd,
            attendeeUserIds: selected,
          }),
        },
      )

      setRequestId(data.request?.id ?? null)
      setCandidates(Array.isArray(data.candidates) ? data.candidates : [])
    } catch (err) {
      const message = err instanceof Error ? err.message : "Unknown error"
      setError(message)
      toast.error(message)
    } finally {
      setLoading(false)
    }
  }

  function formatLocal(iso: string) {
    return DateTime.fromISO(iso, { zone: "utc" }).setZone(timeZone).toFormat("ccc LLL d, t")
  }

  function nameFor(userId: string) {
    const member = memberById.get(userId)
    return member?.user.name || member?.user.email || userId
  }

  async function confirm(rank: number) {
    if (!requestId) return
    setConfirmingRank(rank)
    setConfirmError(null)

    try {
      const data = await fetchJson<{ event?: { id?: string } }>(
        `/api/orgs/${orgId}/suggestions/requests/${requestId}/confirm`,
        {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ candidateRank: rank, writeBackToGoogle: writeBack, conflictCheck: true }),
        },
      )

      if (!data.event?.id) {
        throw new Error("Failed to confirm.")
      }

      router.push(`/events/${data.event.id}`)
    } catch (err) {
      if (err instanceof ApiError && err.status === 409) {
        const message = "Conflict detected. Try a different slot or re-sync calendars."
        setConfirmError(message)
        toast.error(message)
      } else {
        const message = err instanceof Error ? err.message : "Failed to confirm."
        setConfirmError(message)
        toast.error(message)
      }
    } finally {
      setConfirmingRank(null)
    }
  }

  return (
    <div className="space-y-6">
      <div className="space-y-2">
        <h2 className="text-2xl font-semibold">New request - {orgName}</h2>
        <p className="text-sm text-muted-foreground">
          Create a request to generate ranked slots based on member availability.
        </p>
      </div>

      <form
        onSubmit={onSubmit}
        className="space-y-6 rounded-2xl border border-border bg-background/70 p-6 shadow-sm"
      >
        <div className="grid gap-4 md:grid-cols-2">
          <div className="space-y-1">
            <label htmlFor={fieldIds.title} className="text-sm font-medium">
              Title (optional)
            </label>
            <Input
              id={fieldIds.title}
              value={title}
              onChange={(event) => setTitle(event.target.value)}
            />
          </div>
          <div className="space-y-1">
            <label htmlFor={fieldIds.timeZone} className="text-sm font-medium">
              Time zone
            </label>
            <Input
              id={fieldIds.timeZone}
              value={timeZone}
              onChange={(event) => setTimeZone(event.target.value)}
            />
          </div>
          <div className="space-y-1">
            <label htmlFor={fieldIds.rangeStart} className="text-sm font-medium">
              Range start
            </label>
            <Input
              id={fieldIds.rangeStart}
              type="date"
              value={rangeStart}
              onChange={(event) => setRangeStart(event.target.value)}
            />
          </div>
          <div className="space-y-1">
            <label htmlFor={fieldIds.rangeEnd} className="text-sm font-medium">
              Range end
            </label>
            <Input
              id={fieldIds.rangeEnd}
              type="date"
              value={rangeEnd}
              onChange={(event) => setRangeEnd(event.target.value)}
            />
          </div>
          <div className="space-y-1">
            <label className="text-sm font-medium">Duration</label>
            <Select
              value={String(durationMinutes)}
              onValueChange={(value) => setDurationMinutes(Number(value))}
            >
              <SelectTrigger className="w-full">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {[15, 30, 45, 60, 90, 120].map((value) => (
                  <SelectItem key={value} value={String(value)}>
                    {value} min
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          <div className="space-y-1">
            <label className="text-sm font-medium">Step</label>
            <Select value={String(stepMinutes)} onValueChange={(value) => setStepMinutes(Number(value))}>
              <SelectTrigger className="w-full">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {[5, 10, 15, 30].map((value) => (
                  <SelectItem key={value} value={String(value)}>
                    {value} min
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          <div className="space-y-1">
            <label htmlFor={fieldIds.dayStart} className="text-sm font-medium">
              Day start
            </label>
            <Input
              id={fieldIds.dayStart}
              type="time"
              value={dayStart}
              onChange={(event) => setDayStart(event.target.value)}
            />
          </div>
          <div className="space-y-1">
            <label htmlFor={fieldIds.dayEnd} className="text-sm font-medium">
              Day end
            </label>
            <Input
              id={fieldIds.dayEnd}
              type="time"
              value={dayEnd}
              onChange={(event) => setDayEnd(event.target.value)}
            />
          </div>
        </div>

        <div className="space-y-3">
          <div className="flex items-center justify-between">
            <p className="text-sm font-medium">Attendees</p>
            <p className="text-xs text-muted-foreground">Select at least one</p>
          </div>
          <div className="grid gap-2 md:grid-cols-2">
            {members.map((member) => (
              <label
                key={member.userId}
                className="flex items-center gap-3 rounded-lg border border-border/60 px-3 py-2 text-sm"
              >
                <Checkbox
                  checked={selected.includes(member.userId)}
                  onCheckedChange={() => toggleUser(member.userId)}
                />
                <div>
                  <span>{nameFor(member.userId)}</span>
                  <p className="text-xs text-muted-foreground">{member.role}</p>
                </div>
              </label>
            ))}
          </div>
        </div>

        <div className="flex items-center gap-3">
          <Checkbox checked={writeBack} onCheckedChange={(checked) => setWriteBack(Boolean(checked))} />
          <span className="text-sm">Write to Google Calendar (optional)</span>
        </div>

        <div className="flex flex-wrap items-center gap-3">
          <Button type="submit" disabled={loading || selected.length === 0}>
            {loading ? "Generating…" : "Generate suggestions"}
          </Button>
          {error ? <p className="text-sm text-destructive">{error}</p> : null}
        </div>
      </form>

      {confirmError ? <p className="text-sm text-destructive">{confirmError}</p> : null}

      <div className="space-y-4 rounded-2xl border border-border bg-background/70 p-6">
        <div className="flex items-center justify-between">
          <h3 className="text-xl font-semibold">Results</h3>
          <p className="text-sm text-muted-foreground">
            Ranked slots are ordered by score; confirm one to create an event.
          </p>
        </div>
        {candidates.length === 0 ? (
          <p className="text-sm text-muted-foreground">
            No results yet. Create a request to generate ranked slots.
          </p>
        ) : (
          <div className="space-y-4">
            {candidates.map((candidate) => (
              <div
                key={candidate.rank}
                className="space-y-3 rounded-2xl border border-border/60 bg-muted/5 p-4"
              >
                <div className="flex flex-col gap-1 text-sm">
                  <span className="font-semibold">
                    #{candidate.rank}: {formatLocal(candidate.startAt)} — {formatLocal(candidate.endAt)}
                  </span>
                  <span className="text-xs text-muted-foreground">
                    Score: {candidate.score.total.toFixed(2)} (att {candidate.score.attendance.toFixed(2)} · inc {candidate.score.inconvenience.toFixed(2)} · fair {candidate.score.fairness.toFixed(2)})
                  </span>
                  <span className="text-xs text-muted-foreground">
                    Available: {candidate.availableUserIds.length} · Missing: {candidate.missingUserIds.length}
                  </span>
                </div>
                <div className="space-y-1 text-xs text-muted-foreground">
                  {candidate.explanation?.why?.slice(0, 6).map((line, index) => (
                    <p key={index}>{line}</p>
                  ))}
                </div>
                {candidate.missingUserIds.length ? (
                  <div className="text-xs text-muted-foreground">
                    Missing: {candidate.missingUserIds.map((id) => nameFor(id)).join(", ")}
                  </div>
                ) : null}
                <div className="flex justify-end">
                  <Button
                    variant="secondary"
                    onClick={() => confirm(candidate.rank)}
                    disabled={!requestId || confirmingRank === candidate.rank}
                  >
                    {confirmingRank === candidate.rank ? "Confirming…" : "Confirm this slot"}
                  </Button>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="apps/web/src/lib/idempotency.ts">
import { createHash } from "crypto";
import { Prisma, prisma } from "@lattice/db";

const IDEMPOTENCY_KEY_TTL_MS = 1000 * 60 * 15; // 15 minutes

type IdempotencyParams = {
  orgId: string;
  endpoint: string;
  key?: string | null;
  requestHash: string;
};

type IdempotencyResponse =
  | { type: "none" }
  | { type: "conflict" }
  | { type: "response"; response: { status: number; body: unknown } }
  | { type: "incomplete" };

export async function getIdempotencyResponse(params: IdempotencyParams): Promise<IdempotencyResponse> {
  const normalizedKey = normalizeKey(params.key);
  if (!normalizedKey) {
    return { type: "none" };
  }

  const entry = await prisma.idempotencyKey.findUnique({
    where: {
      orgId_endpoint_key: {
        orgId: params.orgId,
        endpoint: params.endpoint,
        key: normalizedKey,
      },
    },
  });

  if (!entry) {
    return { type: "none" };
  }

  if (entry.requestHash !== params.requestHash) {
    return { type: "conflict" };
  }

  if (entry.responseStatus != null) {
    return {
      type: "response",
      response: {
        status: entry.responseStatus,
        body: entry.responseBody,
      },
    };
  }

  return { type: "incomplete" };
}

export async function saveIdempotencyResponse({
  orgId,
  endpoint,
  key,
  requestHash,
  responseStatus,
  responseBody,
}: IdempotencyParams & { responseStatus: number; responseBody: unknown }) {
  const normalizedKey = normalizeKey(key);
  if (!normalizedKey) {
    return;
  }

  try {
    await prisma.idempotencyKey.create({
      data: {
        orgId,
        endpoint,
        key: normalizedKey,
        requestHash,
        responseStatus,
        responseBody,
        expiresAt: new Date(Date.now() + IDEMPOTENCY_KEY_TTL_MS),
      },
    });
  } catch (error: unknown) {
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === "P2002") {
      // Another process already stored the response.
      return;
    }
    throw error;
  }
}

export function computeIdempotencyHash(payload: unknown) {
  const hasher = createHash("sha256");
  hasher.update(stableStringify(payload));
  return hasher.digest("hex");
}

function normalizeKey(key?: string | null) {
  const value = key?.trim();
  return value ? value : null;
}

function stableStringify(value: unknown): string {
  if (value === null) {
    return "null";
  }
  if (typeof value === "undefined") {
    return "undefined";
  }
  if (typeof value === "string") {
    return JSON.stringify(value);
  }
  if (typeof value === "number" || typeof value === "boolean") {
    return value.toString();
  }
  if (value instanceof Date) {
    return JSON.stringify(value.toISOString());
  }
  if (Array.isArray(value)) {
    return `[${value.map((item) => stableStringify(item)).join(",")}]`;
  }
  if (typeof value === "object") {
    const entries = Object.entries(value as Record<string, unknown>)
      .filter(([, entryValue]) => typeof entryValue !== "undefined")
      .sort(([a], [b]) => a.localeCompare(b));
    const serialized = entries
      .map(([key, entryValue]) => `${JSON.stringify(key)}:${stableStringify(entryValue)}`)
      .join(",");
    return `{${serialized}}`;
  }
  return JSON.stringify(value);
}
</file>

<file path="apps/web/test-results/.last-run.json">
{
  "status": "passed",
  "failedTests": []
}
</file>

<file path="apps/web/tests/e2e/helpers/demo-flow.ts">
import { expect, type Locator, type Page } from "@playwright/test";

export const baseUrl = process.env.PLAYWRIGHT_BASE_URL ?? "http://localhost:3000";
export const devEmail = "dev@example.com";

function formatLocalDate(date: Date) {
  const pad = (value: number) => String(value).padStart(2, "0");
  return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
}

export function uniqueOrgName(prefix = "Playwright Org") {
  const suffix = Math.floor(Date.now() / 1000);
  const random = Math.random().toString(36).slice(2, 6);
  return `${prefix} ${suffix}-${random}`;
}

export async function signIn(page: Page) {
  await page.goto(`${baseUrl}/signin`);
  await page.getByLabel("Email (dev/test)").fill(devEmail);
  await Promise.all([
    page.waitForURL(`${baseUrl}/dashboard`),
    page.getByRole("button", { name: "Continue", exact: true }).click(),
  ]);
  await expect(page.getByRole("heading", { name: "Dashboard" })).toBeVisible();
}

export async function createOrg(page: Page, orgName: string) {
  await page.getByPlaceholder("e.g. Delaware DSA").fill(orgName);
  await page.getByRole("button", { name: "Create" }).click();
  const orgLabel = page.locator("span.font-medium", { hasText: orgName });
  await expect(orgLabel).toBeVisible();
}

export async function signInAndCreateOrg(page: Page, orgName: string) {
  await signIn(page);
  await createOrg(page, orgName);
}

export async function goToAvailability(page: Page) {
  await page.goto(`${baseUrl}/availability`);
  await expect(page.getByRole("heading", { name: "Availability", exact: true })).toBeVisible();
}

export async function configureWeeklyAvailability(page: Page, options?: { start?: string; end?: string }) {
  const start = options?.start ?? "09:00";
  const end = options?.end ?? "17:00";
  const template = page.locator('section:has-text("Weekly template")');
  await template.getByRole("button", { name: "+ Add window" }).first().click();
  const timeInputs = template.locator('input[type="time"]');
  await timeInputs.nth(0).fill(start);
  await timeInputs.nth(1).fill(end);
  await template.getByRole("button", { name: "Save template" }).click();
  const saved = page.getByText("Saved");
  await expect(saved).toBeVisible({ timeout: 15000 });
  await expect(saved).toBeHidden({ timeout: 5000 });
}

export async function createAvailabilityOverride(
  page: Page,
  options?: {
    date?: string;
    start?: string;
    end?: string;
    kind?: "UNAVAILABLE" | "AVAILABLE";
    note?: string;
  },
) {
  const now = new Date();
  now.setDate(now.getDate() + 1);
  const overrideDate = options?.date ?? formatLocalDate(now);
  const start = options?.start ?? "12:00";
  const end = options?.end ?? "13:00";
  const kind = options?.kind ?? "UNAVAILABLE";
  const note = options?.note ?? "Playwright override";
  const overridesSection = page.locator('section:has-text("OverridesAdd specific dates")');
  await overridesSection.getByLabel(/^Date/).fill(overrideDate);
  await overridesSection.getByLabel(/^Start/).fill(start);
  await overridesSection.getByLabel(/^End/).fill(end);
  const kindCombobox = overridesSection.getByRole("combobox").first();
  await kindCombobox.click();
  const optionName = kind === "AVAILABLE" ? "AVAILABLE (add)" : "UNAVAILABLE (subtract)";
  await page.getByRole("option", { name: optionName }).click();
  await overridesSection.getByLabel(/^Note/).fill(note);
  await overridesSection.getByRole("button", { name: "Create override" }).click();
  const noteLocator = page.getByText(note);
  await expect(noteLocator).toBeVisible({ timeout: 15000 });
  return note;
}

export async function goToSuggestions(page: Page) {
  await page.goto(`${baseUrl}/suggestions`);
  await expect(
    page.getByRole("heading", { name: "Suggestions", exact: true }),
  ).toBeVisible();
}

export type SuggestionCandidates = {
  list: Locator;
  first: Locator;
};

export async function createSuggestionRequest(
  page: Page,
  title: string,
  opts?: { startDate?: string; endDate?: string },
): Promise<SuggestionCandidates> {
  const form = page.locator("form");
  await form.getByLabel("Title (optional)").fill(title);
  const startDate = opts?.startDate ?? formatLocalDate(new Date());
  const endDate =
    opts?.endDate ?? formatLocalDate(new Date(Date.now() + 7 * 24 * 60 * 60 * 1000));
  await form.getByLabel("Range start").fill(startDate);
  await form.getByLabel("Range end").fill(endDate);
  const generateButton = form.getByRole("button", { name: "Generate suggestions" });
  await expect(generateButton).toBeEnabled({ timeout: 30000 });
  await generateButton.click();
  const candidateList = page.locator(
    'div.space-y-3.rounded-2xl.border:has(button:has-text("Confirm this slot"))',
  );
  await expect(candidateList.first()).toBeVisible({ timeout: 30000 });
  await expect(candidateList.first()).toContainText("attendees available");
  return { list: candidateList, first: candidateList.first() };
}
</file>

<file path="apps/web/package.json">
{
  "name": "web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:e2e:run": "PLAYWRIGHT_TEST=1 playwright test",
    "test:e2e": "bash ../../scripts/run-local-e2e.sh"
  },
  "dependencies": {
    "@auth/core": "^0.34.3",
    "@auth/prisma-adapter": "^1.1.1",
    "@hookform/resolvers": "5.2.2",
    "@lattice/db": "workspace:*",
    "@lattice/shared": "workspace:*",
    "@prisma/client": "^5.16.0",
    "@radix-ui/react-checkbox": "1.3.3",
    "@radix-ui/react-dialog": "1.1.15",
    "@radix-ui/react-dropdown-menu": "2.1.16",
    "@radix-ui/react-label": "2.1.8",
    "@radix-ui/react-select": "2.2.6",
    "@radix-ui/react-slot": "1.2.4",
    "class-variance-authority": "0.7.1",
    "clsx": "2.1.1",
    "dotenv": "17.2.3",
    "googleapis": "169.0.0",
    "lucide-react": "0.562.0",
    "luxon": "3.7.2",
    "next": "16.1.1",
    "next-auth": "5.0.0-beta.30",
    "next-themes": "0.4.6",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-hook-form": "7.71.1",
    "sonner": "2.0.7",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-react": "^5.31.0",
    "tailwind-merge": "3.4.0",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@playwright/test": "1.57.0",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-react": "^5.18.0",
    "babel-plugin-react-compiler": "1.0.0",
    "eslint": "^9",
    "eslint-config-next": "16.1.1",
    "tailwindcss": "^4",
    "tw-animate-css": "1.4.0",
    "typescript": "^5",
    "vitest": "4.0.16"
  }
}
</file>

<file path="packages/db/package.json">
{
  "name": "@lattice/db",
  "private": true,
  "version": "0.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist",
    "prisma"
  ],
  "scripts": {
    "build": "tsup src/index.ts --format esm,cjs",
    "lint": "eslint .",
    "typecheck": "prisma generate && tsc -p tsconfig.json --noEmit",
    "test": "echo \"(no tests yet)\"",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:studio": "prisma studio"
  },
  "dependencies": {
    "@prisma/client": "^5.0.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "eslint": "^9.0.0",
    "prisma": "^5.0.0",
    "ts-node": "^10.9.1",
    "tsup": "^8.0.0",
    "typescript": "^5.0.0"
  },
  "prisma": {
    "seed": "node --loader ts-node/esm ./prisma/seed.ts"
  }
}
</file>

<file path="packages/db/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "."
  },
  "include": ["src/**/*.ts", "prisma/**/*.ts"]
}
</file>

<file path="CONTRIBUTING.md">
# Contributing

## Quick start
1. `pnpm -w db:up`
2. `cp .env.example .env.local`
   - The template already sets up Postgres, Redis, `AUTH_SECRET`, and `NEXT_PUBLIC_APP_URL`, so the dev-only sign-in provider works without hitting Google OAuth.
3. `pnpm -w db:migrate`
4. `pnpm -w dev`

## Repository layout
- `apps/` contains runnable applications and services you can start with `pnpm -w dev`.
- `packages/` holds reusable libraries shared across apps.
- Always run workspace scripts (`pnpm -w ...`) from the repo root so they operate across the monorepo.

## PR expectations
- Small PRs
- Add/update tests when behavior changes
- Run `pnpm -w lint typecheck test build` before opening PR

## Commit style
Prefer conventional commits (optional):
- feat: ...
- fix: ...
- chore: ...
- docs: ...
</file>

<file path="apps/web/src/app/api/orgs/[orgId]/suggestions/requests/route.ts">
import { NextResponse } from "next/server"
import { z } from "zod"
import { DateTime } from "luxon"

import { prisma } from "@lattice/db"
import {
  fail,
  ok,
  ErrorCodes,
  getRedisClient,
  logAudit,
  AuditActions,
  buildRateLimitKey,
  buildRetryAfterHeader,
  enforceRateLimit,
} from "@lattice/shared"
import { loadSuggestionAvailabilityState } from "@/lib/suggestions/state"
import { requireOrgAccess } from "@/lib/guards"
import { parseHHMM } from "@/lib/availability/time"
import { computeRequestKey, generateSuggestions } from "@/lib/suggestions/engine"
import { env } from "@/lib/env"

export const runtime = "nodejs"

const CreateSchema = z.object({
  title: z.string().max(80).optional(),
  timeZone: z.string().min(1),
  rangeStart: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  rangeEnd: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  durationMinutes: z.number().int().min(15).max(240),
  stepMinutes: z.number().int().min(5).max(60).default(15),
  dayStart: z.string().regex(/^\d{2}:\d{2}$/).default("08:00"),
  dayEnd: z.string().regex(/^\d{2}:\d{2}$/).default("20:00"),
  attendeeUserIds: z.array(z.string().min(1)).min(1),
})

const SUGGESTION_CACHE_TTL_SECONDS = env.NODE_ENV === "production" ? 240 : 60

type SuggestionsCacheEntry = {
  requestId: string
  candidateIds: string[]
}

function ensureSortedUnique(ids: string[]) {
  return [...new Set(ids)].sort()
}

async function requireLeader(orgId: string) {
  return requireOrgAccess(orgId, { minRole: "LEADER" })
}

/**
 * @openapi
 * /api/orgs/{orgId}/suggestions/requests:
 *   parameters:
 *     - name: orgId
 *       in: path
 *       required: true
 *       schema:
 *         type: string
 *   get:
 *     summary: Lists cached suggestion requests for leaders.
 *     tags:
 *       - Suggestions
 *     responses:
 *       "200":
 *         description: Recent suggestion requests with top candidates.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     requests:
 *                       type: array
 *   post:
 *     summary: Creates or refreshes a suggestion request.
 *     tags:
 *       - Suggestions
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *               timeZone:
 *                 type: string
 *               rangeStart:
 *                 type: string
 *               rangeEnd:
 *                 type: string
 *               durationMinutes:
 *                 type: integer
 *               stepMinutes:
 *                 type: integer
 *               dayStart:
 *                 type: string
 *               dayEnd:
 *                 type: string
 *               attendeeUserIds:
 *                 type: array
 *                 items:
 *                   type: string
 *             required:
 *               - timeZone
 *               - rangeStart
 *               - rangeEnd
 *               - durationMinutes
 *               - attendeeUserIds
 *     responses:
 *       "200":
 *         description: Suggestions generated and stored.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     request:
 *                       type: object
 *                     candidates:
 *                       type: array
 *       "400":
 *         description: Validation error.
 *       "404":
 *         description: Feature disabled.
 */
export async function GET(_req: Request, { params }: { params: Promise<{ orgId: string }> }) {
  if (!env.SUGGESTIONS_ENABLED) {
    return NextResponse.json(
      fail(ErrorCodes.NOT_FOUND, "Not found"),
      { status: 404 }
    )
  }

  const { orgId } = await params;
  const access = await requireLeader(orgId)
  if (!access.ok) {
    return access.response
  }

  const requests = await prisma.suggestionRequest.findMany({
    where: { orgId: access.membership.orgId },
    orderBy: { createdAt: "desc" },
    take: 25,
    include: {
      attendees: true,
      candidates: { orderBy: { rank: "asc" }, take: 5 },
    },
  })

  return NextResponse.json(ok({ requests }))
}

export async function POST(req: Request, { params }: { params: Promise<{ orgId: string }> }) {
  if (!env.SUGGESTIONS_ENABLED) {
    return NextResponse.json(
      fail(ErrorCodes.NOT_FOUND, "Not found"),
      { status: 404 }
    )
  }

  const { orgId } = await params;
  const access = await requireLeader(orgId)
  if (!access.ok) {
    return access.response
  }

  return await handleCreateSuggestionRequest(req, access)
}

async function handleCreateSuggestionRequest(
  req: Request,
  access: Awaited<ReturnType<typeof requireLeader>>,
) {
  const suggestionLimit = await enforceRateLimit(
    "suggestions",
    buildRateLimitKey(
      "suggestions",
      [access.membership.orgId, access.membership.userId]
    )
  )
  if (!suggestionLimit.allowed) {
    return NextResponse.json(
      suggestionLimit.response,
      {
        status: 429,
        headers: buildRetryAfterHeader(suggestionLimit.retryAfterSeconds),
      }
    )
  }

  const body = CreateSchema.parse(await req.json())

  const attendeeUserIds = ensureSortedUnique(body.attendeeUserIds)

  const dayStartMinute = parseHHMM(body.dayStart)
  const dayEndMinute = parseHHMM(body.dayEnd)
  if (dayStartMinute >= dayEndMinute) {
    return NextResponse.json(
      fail(ErrorCodes.VALIDATION_ERROR, "dayStart must be before dayEnd"),
      { status: 400 }
    )
  }

  const rangeStartUtc = DateTime.fromISO(body.rangeStart, { zone: body.timeZone }).startOf("day").toUTC()
  const rangeEndUtc = DateTime.fromISO(body.rangeEnd, { zone: body.timeZone }).endOf("day").toUTC()

  if (!rangeStartUtc.isValid || !rangeEndUtc.isValid || rangeStartUtc > rangeEndUtc) {
    return NextResponse.json(
      fail(ErrorCodes.INVALID_DATE_RANGE, "Invalid date range"),
      { status: 400 }
    )
  }

  const requestKey = computeRequestKey({
    timeZone: body.timeZone,
    rangeStart: body.rangeStart,
    rangeEnd: body.rangeEnd,
    durationMinutes: body.durationMinutes,
    stepMinutes: body.stepMinutes,
    dayStartMinute,
    dayEndMinute,
    attendeeUserIds,
  })

  const availabilityState = await loadSuggestionAvailabilityState({
    orgId: access.membership.orgId,
    attendeeUserIds,
    rangeStart: rangeStartUtc.toJSDate(),
    rangeEnd: rangeEndUtc.toJSDate(),
  })

  const { templates, overrides, busyBlocks, dataFingerprint } = availabilityState

  const templateByUser = new Map(templates.map((t) => [t.userId, t] as const))
  const overridesByUser = new Map<string, typeof overrides>()
  for (const override of overrides) {
    const list = overridesByUser.get(override.userId) ?? []
    list.push(override)
    overridesByUser.set(override.userId, list)
  }

  const attendees = attendeeUserIds.map((userId) => {
    const template = templateByUser.get(userId)
    const timeZone = template?.timeZone ?? body.timeZone

    return {
      userId,
      timeZone,
      windows:
        template?.windows.map((window) => ({
          dayOfWeek: window.dayOfWeek,
          startMinute: window.startMinute,
          endMinute: window.endMinute,
        })) ?? [],
      overrides: [
        ...(overridesByUser.get(userId) ?? []).map((override) => ({
          startAt: override.startAt.toISOString(),
          endAt: override.endAt.toISOString(),
          kind: override.kind,
        })),
        ...busyBlocks
          .filter((b) => b.userId === userId)
          .map((b) => ({
            startAt: b.startUtc.toISOString(),
            endAt: b.endUtc.toISOString(),
            kind: "UNAVAILABLE" as const,
          })),
      ],
    }
  })

  const cacheKey = `suggestions:${access.membership.orgId}:${requestKey}:${dataFingerprint}`

  const redisClient = await getRedisClient().catch(() => null)
  let cacheEntry: SuggestionsCacheEntry | null = null
  if (redisClient) {
    try {
      const cachedValue = await redisClient.get(cacheKey)
      if (cachedValue) {
        cacheEntry = parseSuggestionsCacheEntry(cachedValue)
      }
    } catch (error) {
      console.warn("[redis] failed to read cached suggestions", error)
    }
  }

  const existing = await prisma.suggestionRequest.findUnique({
    where: { orgId_requestKey: { orgId: access.membership.orgId, requestKey } },
    select: { id: true },
  })

  const shouldUseCache = Boolean(cacheEntry && existing && cacheEntry.requestId === existing.id)

  const requestPayload = {
    title: body.title,
    timeZone: body.timeZone,
    rangeStart: rangeStartUtc.toJSDate(),
    rangeEnd: rangeEndUtc.toJSDate(),
    durationMinutes: body.durationMinutes,
    stepMinutes: body.stepMinutes,
    dayStartMinute,
    dayEndMinute,
    dataFingerprint,
  }

  let requestResult: { id: string }

  if (shouldUseCache && existing) {
    requestResult = await prisma.suggestionRequest.update({
      where: { id: existing.id },
      data: requestPayload,
    })
  } else {
    const generated = generateSuggestions({
      timeZone: body.timeZone,
      rangeStart: body.rangeStart,
      rangeEnd: body.rangeEnd,
      durationMinutes: body.durationMinutes,
      stepMinutes: body.stepMinutes,
      dayStartMinute,
      dayEndMinute,
      attendees,
      maxCandidates: 25,
    })

    const candidatesCreate = generated.map((candidate) => ({
      rank: candidate.rank,
      startAt: new Date(candidate.startAt),
      endAt: new Date(candidate.endAt),
      attendanceRatio: candidate.attendanceRatio,
      scoreTotal: candidate.score.total,
      scoreAttendance: candidate.score.attendance,
      scoreInconvenience: candidate.score.inconvenience,
      scoreFairness: candidate.score.fairness,
      availableUserIds: candidate.availableUserIds,
      missingUserIds: candidate.missingUserIds,
      explanation: candidate.explanation,
    }))

    requestResult = await prisma.$transaction(async (tx) => {
      const existingTx = await tx.suggestionRequest.findUnique({
        where: { orgId_requestKey: { orgId: access.membership.orgId, requestKey } },
        include: { attendees: true },
      })

      const requestData = {
        ...requestPayload,
        attendees: {
          createMany: {
            data: attendeeUserIds.map((userId) => ({ userId })),
          },
        },
        candidates: {
          createMany: {
            data: candidatesCreate,
          },
        },
      }

      if (existingTx) {
        await tx.suggestionCandidate.deleteMany({ where: { requestId: existingTx.id } })
        await tx.suggestionRequestAttendee.deleteMany({ where: { requestId: existingTx.id } })

        return tx.suggestionRequest.update({
          where: { id: existingTx.id },
          data: requestData,
        })
      }

      return tx.suggestionRequest.create({
        data: {
          orgId: access.membership.orgId,
          createdById: access.membership.userId,
          requestKey,
          ...requestData,
        },
      })
    })
  }

  const hydrated = await prisma.suggestionRequest.findUnique({
    where: { id: requestResult.id },
    include: {
      attendees: true,
      candidates: { orderBy: { rank: "asc" } },
    },
  })

  if (!hydrated) {
    return NextResponse.json(
      fail(ErrorCodes.NOT_FOUND, "Failed to load request"),
      { status: 404 }
    )
  }

  await logAudit({
    orgId: access.membership.orgId,
    actorUserId: access.membership.userId,
    action: AuditActions.SUGGESTION_REQUEST_CREATED,
    targetType: "SuggestionRequest",
    targetId: hydrated.id,
    metadata: {
      requestKey,
      attendeeCount: attendeeUserIds.length,
      candidateCount: hydrated.candidates.length,
      isRefresh: Boolean(existing),
    },
  });

  if (redisClient) {
    try {
      const cachePayload: SuggestionsCacheEntry = {
        requestId: requestResult.id,
        candidateIds: hydrated.candidates.map((candidate) => candidate.id),
      }
      await redisClient.set(cacheKey, JSON.stringify(cachePayload), {
        EX: SUGGESTION_CACHE_TTL_SECONDS,
      })
    } catch (error) {
      console.warn("[redis] failed to cache suggestions", error)
    }
  }

  return NextResponse.json(
    ok({
      request: {
        id: hydrated.id,
        orgId: hydrated.orgId,
        timeZone: hydrated.timeZone,
        rangeStart: hydrated.rangeStart.toISOString(),
        rangeEnd: hydrated.rangeEnd.toISOString(),
        durationMinutes: hydrated.durationMinutes,
        stepMinutes: hydrated.stepMinutes,
        dayStartMinute: hydrated.dayStartMinute,
        dayEndMinute: hydrated.dayEndMinute,
        attendeeUserIds: hydrated.attendees.map((item) => item.userId),
      },
      candidates: hydrated.candidates.map((candidate) => ({
        rank: candidate.rank,
        startAt: candidate.startAt.toISOString(),
        endAt: candidate.endAt.toISOString(),
        attendanceRatio: candidate.attendanceRatio,
        score: {
          total: candidate.scoreTotal,
          attendance: candidate.scoreAttendance,
          inconvenience: candidate.scoreInconvenience,
          fairness: candidate.scoreFairness,
        },
        availableUserIds: candidate.availableUserIds,
        missingUserIds: candidate.missingUserIds,
        explanation: candidate.explanation,
      })),
    })
  )
}

function parseSuggestionsCacheEntry(value: string): SuggestionsCacheEntry | null {
  try {
    const parsed = JSON.parse(value)
    if (
      typeof parsed === "object" &&
      parsed !== null &&
      typeof parsed.requestId === "string" &&
      Array.isArray(parsed.candidateIds) &&
      parsed.candidateIds.every((candidateId) => typeof candidateId === "string")
    ) {
      return parsed
    }
  } catch {
    // ignore invalid cache payload
  }
  return null
}
</file>

<file path="apps/web/src/auth.ts">
import NextAuth, { type NextAuthOptions } from "next-auth";
import Credentials from "next-auth/providers/credentials";
import Google from "next-auth/providers/google";
import { PrismaAdapter } from "@auth/prisma-adapter";
import { Prisma, prisma } from "@lattice/db";
import { env } from "@/lib/env";

const providers: NextAuthOptions["providers"] = [];

if (env.AUTH_GOOGLE_ID && env.AUTH_GOOGLE_SECRET) {
  providers.push(
    Google({
      clientId: env.AUTH_GOOGLE_ID,
      clientSecret: env.AUTH_GOOGLE_SECRET,
    })
  );
}

if (env.NODE_ENV !== "production") {
  providers.push(
    Credentials({
      name: "Dev Sign-in",
      credentials: {
        email: { label: "Email", type: "email", placeholder: "dev@example.com" },
      },
      async authorize(credentials) {
        const raw = credentials?.email;
        const email = typeof raw === "string" ? raw.toLowerCase().trim() : "";
        if (!email) return null;

        try {
          const user = await prisma.user.upsert({
            where: { email },
            update: {},
            create: { email, name: email.split("@")[0] },
            select: { id: true, email: true, name: true, image: true },
          });

          return user;
        } catch (error) {
          if (error instanceof Prisma.PrismaClientKnownRequestError && isUniqueConstraintOnEmail(error)) {
            const existingUser = await prisma.user.findUnique({
              where: { email },
              select: { id: true, email: true, name: true, image: true },
            });
            return existingUser ?? null;
          }
          throw error;
        }
      },
    })
  );
}

function isUniqueConstraintOnEmail(error: Prisma.PrismaClientKnownRequestError) {
  const target = error.meta?.target;
  if (error.code !== "P2002") {
    return false;
  }
  if (Array.isArray(target)) {
    return target.includes("email");
  }
  return target === "email";
}

export const {
  handlers: { GET, POST },
  auth,
  signIn,
  signOut,
} = NextAuth({
  adapter: PrismaAdapter(prisma),
  session: { strategy: "jwt" },
  providers,
  pages: { signIn: "/signin" },
  callbacks: {
    async jwt({ token, user }) {
      if (user?.id) token.sub = user.id;
      return token;
    },
    async session({ session, token }) {
      if (session.user && token.sub) {
        session.user.id = token.sub;
      }
      return session;
    },
  },
});
</file>

<file path="scripts/run-local-e2e.sh">
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "$0")/.." && pwd)"
cd "$ROOT_DIR"

log() {
  echo "[local-e2e] $*"
}

if ! command -v pnpm >/dev/null 2>&1; then
  log "pnpm is required to run the e2e helper."
  exit 1
fi

if ! command -v docker >/dev/null 2>&1; then
  log "Docker is required to start the local services."
  exit 1
fi

started_services=0

cleanup() {
  if [ "$started_services" -eq 1 ]; then
    log "Stopping local services..."
    pnpm db:down
  fi
}

trap cleanup EXIT

wait_for_postgres() {
  log "Waiting for Postgres to be ready..."
  for attempt in $(seq 1 30); do
    if docker compose exec -T postgres pg_isready -U lattice >/dev/null 2>&1; then
      log "Postgres is ready."
      return 0
    fi
    sleep 1
  done
  log "Postgres did not become ready in time."
  exit 1
}

wait_for_redis() {
  log "Waiting for Redis to be ready..."
  for attempt in $(seq 1 30); do
    if docker compose exec -T redis redis-cli ping >/dev/null 2>&1; then
      log "Redis is ready."
      return 0
    fi
    sleep 1
  done
  log "Redis did not become ready in time."
  exit 1
}

build_workspace_packages() {
  log "Building workspace packages..."
  pnpm --filter @lattice/db build
  pnpm --filter @lattice/shared build
}

load_prisma_env() {
  if [ -n "${DATABASE_URL:-}" ]; then
    return
  fi

  local env_files=(".env" ".env.local")
  for env_file in "${env_files[@]}"; do
    if [ -f "$env_file" ]; then
      log "Loading environment variables from $env_file"
      set -o allexport
      # shellcheck disable=SC1090
      source "$env_file"
      set +o allexport
    fi
  done
}

ensure_auth_secret() {
  if [ -n "${AUTH_SECRET:-}" ]; then
    return
  fi

  local env_example=".env.example"
  if [ ! -f "$env_example" ]; then
    log "AUTH_SECRET missing and $env_example is not available."
    log "Please set AUTH_SECRET in the environment before running the e2e script."
    exit 1
  fi

  local fallback_auth_secret
  fallback_auth_secret=$(
    # shellcheck disable=SC1090
    source "$env_example"
    printf "%s" "$AUTH_SECRET"
  )

  if [ -z "$fallback_auth_secret" ]; then
    log "AUTH_SECRET is not defined inside $env_example."
    exit 1
  fi

  log "AUTH_SECRET missing; using default from $env_example for the test run."
  export AUTH_SECRET="$fallback_auth_secret"
}

apply_prisma_migrations() {
  log "Applying Prisma migrations..."
  load_prisma_env
  (
    cd packages/db
    pnpm prisma migrate deploy
  )
}

if [ -z "${CI:-}" ]; then
  log "Starting Postgres and Redis via docker compose..."
  pnpm db:up
  started_services=1
  wait_for_postgres
  wait_for_redis
else
  log "CI detected; skipping local service startup."
fi

apply_prisma_migrations

ensure_auth_secret

build_workspace_packages

log "Running Playwright e2e suite..."
log "Generating Prisma client in packages/db..."
pnpm db:generate
PLAYWRIGHT_TEST=1 pnpm -C apps/web test:e2e:run
</file>

</files>
